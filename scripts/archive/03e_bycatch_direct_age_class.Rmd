---
title: "Wandering Albatross Bycatch - Direct Age-Class Method"
author: "WAAL Bycatch Project"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 8
)
```

# Overview

This script implements the **direct age-class approach** using Clay distributions:

1. ✓ BPUE is NOT scaled by % BI (it's a fishery property)
2. ✓ Spatial catchability (β^i) based on literature coverage
3. ✓ **NEW**: Uses Clay age-class densities DIRECTLY instead of as weights
4. ✓ Calculates bycatch per age class in one step

## Method

For each age class:
```
Step 1: Scale Clay distribution by age-class population size → bird density^i
Step 2: Calculate bycatch directly: hooks^i × birds_ageclass^i × catchability^i
Step 3: No intermediate "total BI" calculation needed
```

This is **mathematically equivalent to 03d** but more conceptually direct - we model hooks encountering BI birds of each age class at the catchability rate.

**Comparison with 03d:**
- 03d: Total BI bycatch → partition by age weights
- 03e: Direct calculation per age class using Clay densities
- Should give identical results!

# Setup

```{r libraries}
library(tidyverse)
library(terra)
library(sf)
library(here)
library(viridis)
library(patchwork)
```

# Load Required Data

## Load fishing effort and bird data

```{r load-base-data}
# Fishing effort
fishing_pel <- rast(here("output/rasters/fishing_effort_pelagic.tif"))
fishing_dem <- rast(here("output/rasters/fishing_effort_demersal.tif"))

# Bird densities
total_bird_density <- rast(here("output/rasters/total_bird_density_all_pops.tif"))
pct_bird_island <- rast(here("output/rasters/percentage_bird_island.tif"))

# Clay age-class distributions
bird_fb <- rast(here("data/WAAL_dist_Clay2019/WA_AllMonths_Both_FB_1990-2009.tif"))
bird_sb <- rast(here("data/WAAL_dist_Clay2019/WA_AllMonths_Both_SB_1990-2009.tif"))
bird_nb <- rast(here("data/WAAL_dist_Clay2019/WA_AllMonths_Both_NB_1990-2009.tif"))
bird_j2j3 <- rast(here("data/WAAL_dist_Clay2019/WA_AllMonths_Both_J2+3_1990-2009.tif"))
bird_imm <- rast(here("data/WAAL_dist_Clay2019/WA_AllMonths_Both_IMM_1990-2009.tif"))

bird_dists_raw <- list(fb = bird_fb, sb = bird_sb, nb = bird_nb,
                       j2j3 = bird_j2j3, imm = bird_imm)

cat("Base data loaded\n")
```

## Load demographic proportions

```{r load-demographics}
dem_props <- read_csv(here("data/WAAL_dist_Clay2019/Dem_props copy.csv"),
                      show_col_types = FALSE) %>%
  mutate(Dem_class = str_replace(Dem_class, "J2\\+3", "J2J3"))

dem_props_summary <- dem_props %>%
  group_by(Dem_class) %>%
  summarise(mean_prop = mean(Prop), mean_pop = mean(Pop))

age_class_props <- c(
  fb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "FB"],
  sb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "SB"],
  nb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "NB"],
  j2j3 = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "J2J3"],
  imm = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "IMM"]
)

cat("\nAge class proportions loaded\n")
```

# Define BPUE Studies with Bounding Boxes

Here we define each BPUE study from the literature with its spatial extent. This will eventually come from your literature review (script 04).

```{r define-bpue-studies}
# BPUE studies for PELAGIC longline
# Each study has BPUE value and geographic bounding box
bpue_studies_pel <- tibble(
  study_id = c(
    "Klaer2012_SAtl",
    "Tuck2015_SAtl"
  ),
  bpue_per_1000 = c(
    0.010,   # Klaer 2012
    0.007    # Tuck 2015
  ),
  # Bounding boxes (lat/lon)
  lat_min = c(-60, -60),
  lat_max = c(-30, -35),
  lon_min = c(-70, -65),
  lon_max = c(-20, -25),
  # Metadata
  hooks_observed = c(500000, 750000),
  year_collected = c(2008, 2012),
  notes = c("South Atlantic", "South Atlantic")
)

# BPUE studies for DEMERSAL longline
bpue_studies_dem <- tibble(
  study_id = c(
    "Tuck2015_baseline",
    "Jimenez2020_premit"
  ),
  bpue_per_1000 = c(
    0.001837540,  # Tuck 2015 baseline
    0.029         # Jiménez 2020 pre-mitigation
  ),
  # Bounding boxes
  lat_min = c(-60, -55),
  lat_max = c(-35, -40),
  lon_min = c(-70, -65),
  lon_max = c(-25, -50),
  # Metadata
  hooks_observed = c(300000, 150000),
  year_collected = c(2010, 2018),
  notes = c("Baseline", "Uruguay pre-mitigation")
)

cat("\n=== BPUE STUDIES DEFINED ===\n")
cat("Pelagic:", nrow(bpue_studies_pel), "studies\n")
cat("Demersal:", nrow(bpue_studies_dem), "studies\n")

print(bpue_studies_pel)
print(bpue_studies_dem)
```

**NOTE:** These are placeholder values. When you complete your literature review (script 04), you'll replace this with the full compilation of studies with their actual bounding boxes.

# Align Raster Grids

```{r align-rasters}
# Use total_bird_density as template
template <- total_bird_density

# Resample all to common grid
fishing_pel_aligned <- resample(fishing_pel, template, method = "bilinear")
fishing_dem_aligned <- resample(fishing_dem, template, method = "bilinear")
pct_BI_aligned <- resample(pct_bird_island, template, method = "bilinear")

bird_dists_aligned <- map(bird_dists_raw, function(r) {
  resample(r, template, method = "bilinear")
})

cat("All rasters aligned to common grid\n")
cat("Grid dimensions:", dim(template), "\n")
```

# Create Spatial Catchability Maps

This is the key innovation: each cell gets its own catchability based on which BPUE studies cover it.

## Helper function: Calculate catchability from BPUE

```{r catchability-function}
# Function to calculate catchability (β) from BPUE
# β = (BPUE × H_total) / Σ(H × B)
calculate_catchability <- function(bpue_per_1000, total_hooks, sum_hooks_x_birds) {
  bpue_per_hook <- bpue_per_1000 / 1000
  beta <- (bpue_per_hook * total_hooks) / sum_hooks_x_birds
  return(beta)
}
```

## Helper function: Determine study coverage

```{r coverage-function}
# Function to check if a cell (lat/lon) is covered by a study's bounding box
cell_covered_by_study <- function(cell_lat, cell_lon, study_bbox) {
  covered <- (cell_lat >= study_bbox$lat_min &
              cell_lat <= study_bbox$lat_max &
              cell_lon >= study_bbox$lon_min &
              cell_lon <= study_bbox$lon_max)
  return(covered)
}

# Function to get all studies covering a cell
get_studies_for_cell <- function(cell_lat, cell_lon, bpue_studies) {
  # Check each study
  covered <- map_lgl(1:nrow(bpue_studies), function(i) {
    cell_covered_by_study(cell_lat, cell_lon, bpue_studies[i, ])
  })

  # Return studies that cover this cell
  return(bpue_studies[covered, ])
}
```

## Calculate global parameters (for catchability calculation)

```{r global-parameters}
# Total hooks
total_hooks_pel <- global(fishing_pel_aligned, "sum", na.rm = TRUE)[1,1]
total_hooks_dem <- global(fishing_dem_aligned, "sum", na.rm = TRUE)[1,1]

# Sum of hooks × birds (for denominator of catchability)
hooks_x_birds_pel <- fishing_pel_aligned * total_bird_density
sum_hooks_x_birds_pel <- global(hooks_x_birds_pel, "sum", na.rm = TRUE)[1,1]

hooks_x_birds_dem <- fishing_dem_aligned * total_bird_density
sum_hooks_x_birds_dem <- global(hooks_x_birds_dem, "sum", na.rm = TRUE)[1,1]

cat("\n=== GLOBAL PARAMETERS ===\n")
cat("Total pelagic hooks:  ", format(total_hooks_pel, big.mark = ","), "\n")
cat("Sum(hooks × birds):   ", format(sum_hooks_x_birds_pel, big.mark = ","), "\n")
cat("Total demersal hooks: ", format(total_hooks_dem, big.mark = ","), "\n")
cat("Sum(hooks × birds):   ", format(sum_hooks_x_birds_dem, big.mark = ","), "\n")
```

## Build catchability maps

This is the computationally intensive part - for each cell, we determine which studies cover it and average their catchabilities.

```{r build-catchability-maps}
cat("\n=== BUILDING SPATIAL CATCHABILITY MAPS ===\n")
cat("This may take a few minutes...\n\n")

# Get cell coordinates
coords <- as.data.frame(template, xy = TRUE, cells = TRUE, na.rm = TRUE)  # na.rm = TRUE to only get cells with data

cat("Processing", nrow(coords), "cells\n")

# Initialize vectors to store catchability values
catchability_pel_values <- numeric(nrow(coords))
catchability_dem_values <- numeric(nrow(coords))
n_studies_pel <- integer(nrow(coords))
n_studies_dem <- integer(nrow(coords))

# For each cell, calculate catchability
for (i in 1:nrow(coords)) {
  if (i %% 100 == 0) cat("  Processed", i, "of", nrow(coords), "cells\n")

  cell_lat <- coords$y[i]
  cell_lon <- coords$x[i]

  # PELAGIC
  studies_pel <- get_studies_for_cell(cell_lat, cell_lon, bpue_studies_pel)

  if (nrow(studies_pel) > 0) {
    # Calculate β for each study covering this cell
    betas_pel <- map_dbl(1:nrow(studies_pel), function(j) {
      calculate_catchability(
        studies_pel$bpue_per_1000[j],
        total_hooks_pel,
        sum_hooks_x_birds_pel
      )
    })
    # Weighted average by sample size (hooks observed)
    catchability_pel_values[i] <- weighted.mean(betas_pel,
                                                 w = studies_pel$hooks_observed)
    n_studies_pel[i] <- nrow(studies_pel)
  } else {
    catchability_pel_values[i] <- NA
    n_studies_pel[i] <- 0
  }

  # DEMERSAL
  studies_dem <- get_studies_for_cell(cell_lat, cell_lon, bpue_studies_dem)

  if (nrow(studies_dem) > 0) {
    betas_dem <- map_dbl(1:nrow(studies_dem), function(j) {
      calculate_catchability(
        studies_dem$bpue_per_1000[j],
        total_hooks_dem,
        sum_hooks_x_birds_dem
      )
    })
    # Weighted average by sample size (hooks observed)
    catchability_dem_values[i] <- weighted.mean(betas_dem,
                                                 w = studies_dem$hooks_observed)
    n_studies_dem[i] <- nrow(studies_dem)
  } else {
    catchability_dem_values[i] <- NA
    n_studies_dem[i] <- 0
  }
}

# Add to coords dataframe
coords <- coords %>%
  mutate(
    catchability_pel = catchability_pel_values,
    catchability_dem = catchability_dem_values,
    n_studies_pel = n_studies_pel,
    n_studies_dem = n_studies_dem
  )

cat("\n=== COVERAGE STATISTICS ===\n")
cat("Pelagic:\n")
cat("  Cells covered:", sum(coords$n_studies_pel > 0), "/", nrow(coords), "\n")
cat("  Cells with >1 study:", sum(coords$n_studies_pel > 1), "\n")
cat("  Max studies per cell:", max(coords$n_studies_pel), "\n")

cat("\nDemersal:\n")
cat("  Cells covered:", sum(coords$n_studies_dem > 0), "/", nrow(coords), "\n")
cat("  Cells with >1 study:", sum(coords$n_studies_dem > 1), "\n")
cat("  Max studies per cell:", max(coords$n_studies_dem), "\n")
```

## Fill gaps using expert elicitation

For cells not covered by any study, we use expert elicitation to assign appropriate BPUE values based on similarity in fishing operations and mitigation practices.

```{r fill-gaps-expert}
# EXPERT ELICITATION FRAMEWORK
# Define gap-filling rules based on fishing characteristics
# This will be populated based on expert consultation

# Example structure for expert-assigned BPUE values
# Each row defines a spatial region and the BPUE to use for gaps there
expert_gap_fill <- tibble(
  region_name = c(
    "South_Atlantic_EEZ",      # Well-regulated areas
    "High_Seas_South_Atlantic", # Less regulated
    "Indian_Ocean_North",       # Different fishing practices
    "Pacific_Areas"             # Distant regions
  ),
  # Geographic extent
  lat_min = c(-60, -60, -45, -50),
  lat_max = c(-30, -30, -20, -20),
  lon_min = c(-70, -70, 20, -180),
  lon_max = c(-20, -20, 100, -100),
  # Expert-assigned BPUE for gaps (based on similar fisheries)
  bpue_pel_expert = c(0.007, 0.010, 0.012, 0.008),
  bpue_dem_expert = c(0.002, 0.015, 0.020, 0.005),
  # Rationale
  justification = c(
    "Similar to South Georgia - good mitigation",
    "High seas - variable mitigation",
    "Similar to Indian Ocean studies - limited mitigation",
    "Pacific baseline - moderate practices"
  )
)

cat("\n=== EXPERT ELICITATION FRAMEWORK ===\n")
cat("Gap-filling regions defined:", nrow(expert_gap_fill), "\n")
print(expert_gap_fill)

# Function to assign expert BPUE to a cell based on location
assign_expert_bpue <- function(cell_lat, cell_lon, expert_table) {
  # Find which expert region this cell falls in
  in_region <- map_lgl(1:nrow(expert_table), function(i) {
    cell_lat >= expert_table$lat_min[i] &
    cell_lat <= expert_table$lat_max[i] &
    cell_lon >= expert_table$lon_min[i] &
    cell_lon <= expert_table$lon_max[i]
  })

  if (any(in_region)) {
    # Use first matching region (could refine with priority rules)
    idx <- which(in_region)[1]
    return(expert_table[idx, ])
  } else {
    # Default to global mean if outside all expert regions
    return(NULL)
  }
}

# Calculate global mean catchability (fallback for cells outside expert regions)
global_mean_bpue_pel <- weighted.mean(bpue_studies_pel$bpue_per_1000,
                                      w = bpue_studies_pel$hooks_observed)
global_catchability_pel <- calculate_catchability(
  global_mean_bpue_pel, total_hooks_pel, sum_hooks_x_birds_pel
)

global_mean_bpue_dem <- weighted.mean(bpue_studies_dem$bpue_per_1000,
                                      w = bpue_studies_dem$hooks_observed)
global_catchability_dem <- calculate_catchability(
  global_mean_bpue_dem, total_hooks_dem, sum_hooks_x_birds_dem
)

cat("\n=== FALLBACK (GLOBAL WEIGHTED MEAN) ===\n")
cat("Pelagic:  ", format(global_catchability_pel, scientific = TRUE), "\n")
cat("Demersal: ", format(global_catchability_dem, scientific = TRUE), "\n")

# Fill gaps using expert assignments
n_gaps_filled_pel <- 0
n_gaps_filled_dem <- 0

for (i in 1:nrow(coords)) {
  # PELAGIC gaps
  if (is.na(coords$catchability_pel[i])) {
    expert_assignment <- assign_expert_bpue(coords$y[i], coords$x[i], expert_gap_fill)
    if (!is.null(expert_assignment)) {
      coords$catchability_pel[i] <- calculate_catchability(
        expert_assignment$bpue_pel_expert,
        total_hooks_pel,
        sum_hooks_x_birds_pel
      )
      n_gaps_filled_pel <- n_gaps_filled_pel + 1
    } else {
      coords$catchability_pel[i] <- global_catchability_pel
    }
  }

  # DEMERSAL gaps
  if (is.na(coords$catchability_dem[i])) {
    expert_assignment <- assign_expert_bpue(coords$y[i], coords$x[i], expert_gap_fill)
    if (!is.null(expert_assignment)) {
      coords$catchability_dem[i] <- calculate_catchability(
        expert_assignment$bpue_dem_expert,
        total_hooks_dem,
        sum_hooks_x_birds_dem
      )
      n_gaps_filled_dem <- n_gaps_filled_dem + 1
    } else {
      coords$catchability_dem[i] <- global_catchability_dem
    }
  }
}

cat("\n=== GAP FILLING COMPLETE ===\n")
cat("Pelagic gaps filled with expert values:  ", n_gaps_filled_pel, "\n")
cat("Pelagic gaps filled with global mean:    ",
    sum(is.na(catchability_pel_values)) - n_gaps_filled_pel, "\n")
cat("Demersal gaps filled with expert values: ", n_gaps_filled_dem, "\n")
cat("Demersal gaps filled with global mean:   ",
    sum(is.na(catchability_dem_values)) - n_gaps_filled_dem, "\n")
```

## Convert to rasters

```{r create-catchability-rasters}
# Create catchability rasters
# Need to match template structure

# Create empty rasters
catchability_pel_rast <- template
catchability_dem_rast <- template

# Fill with values using cell indices
catchability_pel_rast[coords$cell] <- coords$catchability_pel
catchability_dem_rast[coords$cell] <- coords$catchability_dem

# Create coverage maps (number of studies)
n_studies_pel_rast <- template
n_studies_dem_rast <- template
n_studies_pel_rast[coords$cell] <- coords$n_studies_pel
n_studies_dem_rast[coords$cell] <- coords$n_studies_dem

cat("\nCatchability rasters created\n")
```

# Visualize Catchability Maps

```{r map-catchability, fig.width=12, fig.height=10}
# Load basemap
ne_land <- st_read(here("data/ne_10m_land/ne_10m_land.shp"), quiet = TRUE)
map_extent <- c(-180, 180, -90, 0)

# Function to map catchability
map_catchability <- function(rast_obj, title) {
  df <- as.data.frame(rast_obj, xy = TRUE, na.rm = TRUE)
  names(df)[3] <- "catchability"

  ggplot(df, aes(x = x, y = y, fill = catchability)) +
    geom_raster() +
    geom_sf(data = ne_land, inherit.aes = FALSE, fill = "grey80", color = NA) +
    coord_sf(xlim = map_extent[1:2], ylim = map_extent[3:4], expand = FALSE) +
    scale_fill_viridis_c(
      name = "Catchability (β)",
      na.value = "white",
      option = "magma"
    ) +
    labs(title = title) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 11, face = "bold"),
      legend.position = "right"
    )
}

# Map pelagic catchability
p_catch_pel <- map_catchability(catchability_pel_rast,
                                "Pelagic Catchability (β) - Spatially Varying")

# Map demersal catchability
p_catch_dem <- map_catchability(catchability_dem_rast,
                                "Demersal Catchability (β) - Spatially Varying")

# Display
p_catch_pel / p_catch_dem

# Save
dir.create(here("output/maps"), showWarnings = FALSE, recursive = TRUE)
ggsave(here("output/maps/catchability_pelagic_spatial_03d.png"),
       p_catch_pel, width = 10, height = 6, dpi = 300)
ggsave(here("output/maps/catchability_demersal_spatial_03d.png"),
       p_catch_dem, width = 10, height = 6, dpi = 300)
```

## Map study coverage

```{r map-coverage, fig.width=12, fig.height=6}
# Function to map number of studies
map_coverage <- function(rast_obj, title) {
  df <- as.data.frame(rast_obj, xy = TRUE, na.rm = TRUE)
  names(df)[3] <- "n_studies"

  ggplot(df, aes(x = x, y = y, fill = factor(n_studies))) +
    geom_raster() +
    geom_sf(data = ne_land, inherit.aes = FALSE, fill = "grey80", color = NA) +
    coord_sf(xlim = map_extent[1:2], ylim = map_extent[3:4], expand = FALSE) +
    scale_fill_viridis_d(
      name = "# Studies",
      na.value = "white",
      option = "plasma"
    ) +
    labs(title = title) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 11, face = "bold"),
      legend.position = "right"
    )
}

p_cov_pel <- map_coverage(n_studies_pel_rast, "Pelagic: Number of Studies per Cell")
p_cov_dem <- map_coverage(n_studies_dem_rast, "Demersal: Number of Studies per Cell")

p_cov_pel | p_cov_dem
```

# Calculate Bycatch Using Direct Age-Class Method

Instead of calculating total BI bycatch and partitioning, we calculate bycatch for each age class directly using Clay densities.

## Scale Clay distributions to match Carneiro units

CRITICAL: Catchability was calculated using Carneiro `total_bird_density` which has specific units. We need to scale Clay distributions to match those units!

```{r scale-clay-densities}
# First, figure out what units Carneiro uses
carneiro_sum <- global(total_bird_density, "sum", na.rm = TRUE)[1,1]
cat("\n=== CARNEIRO DENSITY UNITS ===\n")
cat("total_bird_density sums to:", carneiro_sum, "\n")
cat("(This is the scaling we need to match!)\n")

# Calculate BI total in Carneiro units
BI_total_density_carneiro <- total_bird_density * pct_BI_aligned
BI_sum_carneiro <- global(BI_total_density_carneiro, "sum", na.rm = TRUE)[1,1]
cat("\nBI portion sums to:", BI_sum_carneiro, "\n")

# Get age class proportions
age_class_props <- c(
  fb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "FB"],
  sb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "SB"],
  nb = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "NB"],
  j2j3 = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "J2J3"],
  imm = dem_props_summary$mean_prop[dem_props_summary$Dem_class == "IMM"]
)

cat("\n=== AGE CLASS PROPORTIONS ===\n")
print(age_class_props)

# Normalize Clay distributions (so they sum to 1)
bird_dists_norm <- map(bird_dists_aligned, function(r) {
  r_zero <- subst(r, NA, 0)
  r_sum <- global(r_zero, "sum", na.rm = TRUE)[1,1]
  return(r_zero / r_sum)
})

# Scale each age class to match Carneiro units
# Each age class should sum to: BI_sum_carneiro × age_class_proportion
bird_densities_by_age <- map2(bird_dists_norm, age_class_props, function(r, prop) {
  target_sum <- BI_sum_carneiro * prop
  r * target_sum
})

cat("\n=== BIRD DENSITIES CREATED (in Carneiro units) ===\n")
cat("Each raster now uses same units as Carneiro total_bird_density\n")

# Verify they sum to expected totals
sums <- map_dbl(bird_densities_by_age, ~global(.x, "sum", na.rm = TRUE)[1,1])
cat("\nVerification - sums by age class:\n")
print(round(sums, 4))
cat("\nTotal across ages:", round(sum(sums), 4), "\n")
cat("Expected (BI_sum_carneiro):", round(BI_sum_carneiro, 4), "\n")
cat("Match?", abs(sum(sums) - BI_sum_carneiro) < 0.001, "\n")
```

## Calculate bycatch directly per age class

```{r calculate-bycatch-direct}
cat("\n=== CALCULATING BYCATCH DIRECTLY PER AGE CLASS ===\n")

# PELAGIC: For each age class, bycatch = hooks × birds_ageclass × catchability
byc_pel_by_age <- imap(bird_densities_by_age, function(bird_density, age_name) {
  bycatch_map <- fishing_pel_aligned * bird_density * catchability_pel_rast
  bycatch_total <- global(bycatch_map, "sum", na.rm = TRUE)[1,1]

  cat(toupper(age_name), ": ", round(bycatch_total, 2), "birds (pelagic)\n")

  return(list(map = bycatch_map, total = bycatch_total))
})

cat("\n")

# DEMERSAL: For each age class
byc_dem_by_age <- imap(bird_densities_by_age, function(bird_density, age_name) {
  bycatch_map <- fishing_dem_aligned * bird_density * catchability_dem_rast
  bycatch_total <- global(bycatch_map, "sum", na.rm = TRUE)[1,1]

  cat(toupper(age_name), ": ", round(bycatch_total, 2), "birds (demersal)\n")

  return(list(map = bycatch_map, total = bycatch_total))
})

# Extract totals
byc_pel_totals <- map_dbl(byc_pel_by_age, "total")
byc_dem_totals <- map_dbl(byc_dem_by_age, "total")

cat("\n=== TOTALS ===\n")
cat("Pelagic:  ", round(sum(byc_pel_totals), 2), "birds/year\n")
cat("Demersal: ", round(sum(byc_dem_totals), 2), "birds/year\n")
cat("TOTAL:    ", round(sum(byc_pel_totals) + sum(byc_dem_totals), 2), "birds/year\n")
```

## Summary table

```{r summary-table}
bycatch_summary <- tibble(
  age_class = names(byc_pel_totals),
  pelagic = byc_pel_totals,
  demersal = byc_dem_totals,
  total = byc_pel_totals + byc_dem_totals
) %>%
  bind_rows(tibble(
    age_class = "TOTAL",
    pelagic = sum(byc_pel_totals),
    demersal = sum(byc_dem_totals),
    total = sum(byc_pel_totals) + sum(byc_dem_totals)
  ))

cat("\n=== TOTAL BYCATCH SUMMARY ===\n")
print(bycatch_summary)
```

# Visualize Bycatch Maps

## Basemap reference

```{r basemap-reference, fig.width=12, fig.height=8}
# Create a blank basemap for reference
ext_rast <- ext(template)

p_basemap <- ggplot() +
  geom_sf(data = ne_land, fill = "grey80", color = "grey40", linewidth = 0.3) +
  coord_sf(xlim = c(ext_rast[1], ext_rast[2]),
           ylim = c(ext_rast[3], ext_rast[4]),
           expand = FALSE) +
  labs(title = "Study Area - Southern Ocean") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    panel.grid.major = element_line(color = "grey90", linewidth = 0.5),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA)
  )

print(p_basemap)

# Save basemap
ggsave(here("output/maps/basemap_reference.png"), p_basemap,
       width = 12, height = 8, dpi = 300)
```

## Map total bird density (Carneiro)

```{r map-bird-density, fig.width=12, fig.height=8}
# Map total WAAL bird density from Carneiro et al.
# Set values below 0.001 to NA so they appear as white/blank
bird_density_masked <- total_bird_density
bird_density_masked[bird_density_masked < 0.001] <- NA

df_birds <- as.data.frame(bird_density_masked, xy = TRUE, na.rm = TRUE)
names(df_birds)[3] <- "density"

p_bird_density <- ggplot(df_birds, aes(x = x, y = y, fill = density)) +
  geom_raster() +
  geom_sf(data = ne_land, inherit.aes = FALSE, fill = "grey80", color = NA) +
  coord_sf(xlim = c(ext_rast[1], ext_rast[2]),
           ylim = c(ext_rast[3], ext_rast[4]),
           expand = FALSE) +
  scale_fill_viridis_c(
    name = "Bird Density\n(birds/cell)",
    na.value = "white",
    option = "viridis",
    direction = -1  # Reverse color ramp like Clay maps
  ) +
  labs(title = "Total WAAL Bird Density - All Populations (Carneiro et al. 2020)") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, face = "bold"),
    legend.position = "right"
  )

print(p_bird_density)

# Save map
ggsave(here("output/maps/bird_density_total_carneiro.png"), p_bird_density,
       width = 12, height = 8, dpi = 300)
```

## Map total bycatch density

```{r map-bycatch-total, fig.width=12, fig.height=6}
# Function to map bycatch density
map_bycatch <- function(rast_obj, title) {
  df <- as.data.frame(rast_obj, xy = TRUE, na.rm = TRUE)
  names(df)[3] <- "bycatch"

  ext_rast <- ext(rast_obj)

  ggplot(df, aes(x = x, y = y, fill = bycatch)) +
    geom_raster() +
    geom_sf(data = ne_land, inherit.aes = FALSE, fill = "grey80", color = NA) +
    coord_sf(xlim = c(ext_rast[1], ext_rast[2]),
             ylim = c(ext_rast[3], ext_rast[4]),
             expand = FALSE) +
    scale_fill_viridis_c(
      name = "Bycatch\nDensity",
      na.value = "white",
      direction = -1
    ) +
    labs(title = title) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 12, face = "bold"),
      legend.position = "right"
    )
}

# Calculate total bycatch maps for visualization (sum across age classes)
BI_total_bycatch_pel <- Reduce("+", map(byc_pel_by_age, "map"))
BI_total_bycatch_dem <- Reduce("+", map(byc_dem_by_age, "map"))

# Create total bycatch maps
p_byc_pel <- map_bycatch(BI_total_bycatch_pel,
                         "Total Pelagic Bycatch Density (Direct Age-Class Method)")
p_byc_dem <- map_bycatch(BI_total_bycatch_dem,
                         "Total Demersal Bycatch Density (Direct Age-Class Method)")

# Display side by side
p_byc_pel | p_byc_dem

# Save maps
ggsave(here("output/maps/bycatch_pelagic_total_03e.png"), p_byc_pel,
       width = 10, height = 6, dpi = 300)
ggsave(here("output/maps/bycatch_demersal_total_03e.png"), p_byc_dem,
       width = 10, height = 6, dpi = 300)
```

## Map by age class

```{r map-by-age-class, fig.width=15, fig.height=10}
# Extract map objects from the lists
byc_pel_maps <- map(byc_pel_by_age, "map")
byc_dem_maps <- map(byc_dem_by_age, "map")

# Create maps for each age class (pelagic)
byc_pel_age_maps <- imap(byc_pel_maps, function(r, age) {
  map_bycatch(r, paste0("Pelagic Bycatch: ", toupper(age), " (Direct Age-Class Method)"))
})

# Display all pelagic age class maps
wrap_plots(byc_pel_age_maps, ncol = 3)

# Save individual age class maps
iwalk(byc_pel_age_maps, function(p, age) {
  ggsave(here(paste0("output/maps/bycatch_pelagic_", age, "_03e.png")),
         p, width = 8, height = 6, dpi = 300)
})

# Create maps for each age class (demersal)
byc_dem_age_maps <- imap(byc_dem_maps, function(r, age) {
  map_bycatch(r, paste0("Demersal Bycatch: ", toupper(age), " (Direct Age-Class Method)"))
})

# Display all demersal age class maps
wrap_plots(byc_dem_age_maps, ncol = 3)

# Save individual age class maps
iwalk(byc_dem_age_maps, function(p, age) {
  ggsave(here(paste0("output/maps/bycatch_demersal_", age, "_03e.png")),
         p, width = 8, height = 6, dpi = 300)
})
```

## Per capita rates

```{r per-capita-rates}
pop_sizes <- c(
  fb = dem_props_summary$mean_pop[dem_props_summary$Dem_class == "FB"],
  sb = dem_props_summary$mean_pop[dem_props_summary$Dem_class == "SB"],
  nb = dem_props_summary$mean_pop[dem_props_summary$Dem_class == "NB"],
  j2j3 = dem_props_summary$mean_pop[dem_props_summary$Dem_class == "J2J3"],
  imm = dem_props_summary$mean_pop[dem_props_summary$Dem_class == "IMM"]
)

percap_pel <- byc_pel_totals / pop_sizes
percap_dem <- byc_dem_totals / pop_sizes

percap_summary <- tibble(
  age_class = names(pop_sizes),
  population = pop_sizes,
  byc_pel = byc_pel_totals,
  byc_dem = byc_dem_totals,
  percap_pel = percap_pel,
  percap_dem = percap_dem,
  percap_total = percap_pel + percap_dem
)

cat("\n=== PER CAPITA RATES ===\n")
print(percap_summary)
```

# Compare with Scripts 03c and 03d

This should give IDENTICAL results to 03d (same catchability, different calculation path).

```{r compare-03d}
if (file.exists(here("output/bycatch_summary_03d.csv"))) {
  byc_03d <- read_csv(here("output/bycatch_summary_03d.csv"),
                      show_col_types = FALSE)

  comparison_03d <- tibble(
    age_class = bycatch_summary$age_class,
    pelagic_03d = byc_03d$pelagic,
    pelagic_03e = bycatch_summary$pelagic,
    pelagic_diff = bycatch_summary$pelagic - byc_03d$pelagic,
    demersal_03d = byc_03d$demersal,
    demersal_03e = bycatch_summary$demersal,
    demersal_diff = bycatch_summary$demersal - byc_03d$demersal
  )

  cat("\n=== COMPARISON: SCRIPT 03d vs 03e ===\n")
  cat("These should be IDENTICAL (or differ only by rounding)\n\n")
  print(comparison_03d)

  cat("\n=== SUMMARY ===\n")
  cat("Total pelagic (03d):   ", round(byc_03d$pelagic[nrow(byc_03d)], 2), "\n")
  cat("Total pelagic (03e):   ", round(sum(byc_pel_totals), 2), "\n")
  cat("Difference:            ", round(sum(byc_pel_totals) - byc_03d$pelagic[nrow(byc_03d)], 4), "\n\n")

  cat("Total demersal (03d):  ", round(byc_03d$demersal[nrow(byc_03d)], 2), "\n")
  cat("Total demersal (03e):  ", round(sum(byc_dem_totals), 2), "\n")
  cat("Difference:            ", round(sum(byc_dem_totals) - byc_03d$demersal[nrow(byc_03d)], 4), "\n")

  write_csv(comparison_03d, here("output/bycatch_comparison_03d_vs_03e.csv"))
} else {
  cat("\nScript 03d results not found for comparison\n")
}
```

```{r compare-03c}
if (file.exists(here("output/bycatch_summary_03c.csv"))) {
  byc_03c <- read_csv(here("output/bycatch_summary_03c.csv"),
                      show_col_types = FALSE)

  comparison_03c <- tibble(
    age_class = bycatch_summary$age_class,
    pelagic_03c = byc_03c$pelagic,
    pelagic_03e = bycatch_summary$pelagic,
    pelagic_ratio = bycatch_summary$pelagic / byc_03c$pelagic,
    demersal_03c = byc_03c$demersal,
    demersal_03e = bycatch_summary$demersal,
    demersal_ratio = bycatch_summary$demersal / byc_03c$demersal
  )

  cat("\n=== COMPARISON: SCRIPT 03c vs 03e ===\n")
  cat("03c uses global catchability, 03e uses spatial catchability\n\n")
  print(comparison_03c)

  cat("\n=== SUMMARY ===\n")
  cat("Total pelagic (03c):   ", round(byc_03c$pelagic[nrow(byc_03c)], 2), "\n")
  cat("Total pelagic (03e):   ", round(sum(byc_pel_totals), 2), "\n")
  cat("Ratio (03e/03c):       ", round(sum(byc_pel_totals) / byc_03c$pelagic[nrow(byc_03c)], 3), "×\n\n")

  cat("Total demersal (03c):  ", round(byc_03c$demersal[nrow(byc_03c)], 2), "\n")
  cat("Total demersal (03e):  ", round(sum(byc_dem_totals), 2), "\n")
  cat("Ratio (03e/03c):       ", round(sum(byc_dem_totals) / byc_03c$demersal[nrow(byc_03c)], 3), "×\n")

  write_csv(comparison_03c, here("output/bycatch_comparison_03c_vs_03e.csv"))
} else {
  cat("\nScript 03c results not found for comparison\n")
}
```

# Save Outputs

```{r save-outputs}
dir.create(here("output/rasters"), showWarnings = FALSE, recursive = TRUE)

# Save catchability rasters (same as 03d)
writeRaster(catchability_pel_rast,
            here("output/rasters/catchability_pelagic_spatial_03e.tif"),
            overwrite = TRUE)
writeRaster(catchability_dem_rast,
            here("output/rasters/catchability_demersal_spatial_03e.tif"),
            overwrite = TRUE)

# Save coverage rasters
writeRaster(n_studies_pel_rast,
            here("output/rasters/n_studies_pelagic_03e.tif"),
            overwrite = TRUE)
writeRaster(n_studies_dem_rast,
            here("output/rasters/n_studies_demersal_03e.tif"),
            overwrite = TRUE)

# Save bird density rasters (NEW - the Clay densities we created)
iwalk(bird_densities_by_age, function(r, age_name) {
  writeRaster(r, here(paste0("output/rasters/bird_density_", age_name, "_03e.tif")),
              overwrite = TRUE)
})

# Save bycatch summaries
write_csv(bycatch_summary, here("output/bycatch_summary_03e.csv"))
write_csv(percap_summary, here("output/bycatch_percapita_summary_03e.csv"))

# Save study metadata
write_csv(bpue_studies_pel, here("output/bpue_studies_pelagic_03e.csv"))
write_csv(bpue_studies_dem, here("output/bpue_studies_demersal_03e.csv"))

# Save expert elicitation framework
write_csv(expert_gap_fill, here("output/expert_gap_fill_03e.csv"))

cat("\nAll outputs saved successfully\n")
```

# Diagnostics

```{r diagnostics}
cat("\n=== DIAGNOSTIC VALUES ===\n\n")

cat("Catchability spatial variation:\n")
cat("Pelagic β:\n")
cat("  Min:  ", format(global(catchability_pel_rast, "min", na.rm = TRUE)[1,1], scientific = TRUE), "\n")
cat("  Mean: ", format(global(catchability_pel_rast, "mean", na.rm = TRUE)[1,1], scientific = TRUE), "\n")
cat("  Max:  ", format(global(catchability_pel_rast, "max", na.rm = TRUE)[1,1], scientific = TRUE), "\n\n")

cat("Demersal β:\n")
cat("  Min:  ", format(global(catchability_dem_rast, "min", na.rm = TRUE)[1,1], scientific = TRUE), "\n")
cat("  Mean: ", format(global(catchability_dem_rast, "mean", na.rm = TRUE)[1,1], scientific = TRUE), "\n")
cat("  Max:  ", format(global(catchability_dem_rast, "max", na.rm = TRUE)[1,1], scientific = TRUE), "\n\n")

cat("Study coverage:\n")
cat("Pelagic: ", sum(coords$n_studies_pel > 0), "cells covered (",
    round(100 * sum(coords$n_studies_pel > 0) / nrow(coords), 1), "%)\n")
cat("Demersal:", sum(coords$n_studies_dem > 0), "cells covered (",
    round(100 * sum(coords$n_studies_dem > 0) / nrow(coords), 1), "%)\n\n")

cat("Cells with multiple studies:\n")
cat("Pelagic: ", sum(coords$n_studies_pel > 1), "cells\n")
cat("Demersal:", sum(coords$n_studies_dem > 1), "cells\n")
```

# Notes

**Implementation Notes:**

1. **Direct age-class approach**: This script (03e) uses Clay distributions directly to calculate bycatch per age class, rather than calculating total BI bycatch and partitioning (03d approach). Both are mathematically equivalent but this is more conceptually direct.

2. **Bird density calculation**: Clay distributions are normalized (sum to 1) then scaled by age-class population size to get actual bird density (birds per cell). This represents where BI birds of each age class are located.

3. **Bycatch calculation**: For each age class, we calculate: `bycatch^i = hooks^i × bird_density_ageclass^i × catchability^i`. No intermediate "total BI bycatch" step needed.

4. **Study definitions**: The BPUE studies defined here are placeholders. When you complete your literature review (script 04), you'll replace this section with the actual compiled studies (~20-30 studies with bounding boxes).

5. **Averaging method**: When multiple studies overlap a cell, we use **weighted mean by sample size** (hooks observed). This gives more weight to studies with larger sample sizes, which are generally more reliable.

6. **Gap filling**: Cells not covered by any literature study use **expert elicitation** to assign appropriate BPUE values based on similarity in fishing operations, mitigation practices, and regulatory environment.

7. **Comparison with 03d**: Results should be IDENTICAL to 03d (or differ only by rounding error). Both use the same catchability maps, just apply them differently:
   - 03d: Total WAAL → allocate to BI → partition by age
   - 03e: Direct calculation per age class using Clay densities

8. **Supervisor feedback implemented**:
   - ✓ BPUE is NOT scaled by % BI (correct - it's a fishery property)
   - ✓ Each cell gets its own β based on literature coverage
   - ✓ Multiple studies averaged using **weighted mean by sample size**
   - ✓ Gaps filled using **expert elicitation** based on fishing similarity
   - ✓ Uses Clay age-class distributions directly (more conceptually clean)

# Session Info

```{r session-info}
sessionInfo()
```
