---
title: "WAAL bycatch 5-27-25"
output: html_notebook
---

```{r, echo= FALSE, include =FALSE}
library(here)
library(tidyverse)
library(RColorBrewer)

#set up various plotting themes
themeo <-theme_classic()+
  theme(strip.background = element_blank(),
        panel.grid.major = element_line(colour = "transparent"), 
        panel.grid.minor = element_line(colour = "transparent"),
        axis.line = element_blank(),
        axis.title = element_text(color = "black", size = 10),
        axis.ticks.length=unit(-0.1, "cm"),
        axis.ticks = element_line(color = "black", size = .25),
        axis.ticks.x = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=.5),
        panel.spacing = unit(1, "lines"),
        legend.position = "bottom",
        legend.title = element_text(colour = "black", size = 10, face = "bold"),
        legend.text = element_text(color = "black", size =8)) #default legend position
```


*SET UP DEMO MATRIX, VRs, CALCULATE MEAN POP GROWTH RATE, SSD, etc*

**set vital rates**
```{r}
#breeding prob
b_EF	<- 0.746 #experienced failed
b_ENB	<- 0.589 #experienced non breeding
b_ES  <- 0.016 #experienced successful
b_IF  <- 0.744 #inexperienced failed
b_Imm	<- 0.101 #immature
b_IS  <- 0.011 #inexperienced successful
b_PF	<- 0.941 #sabbatical 

#success prob
k_EF	<- 0.631 #experienced failed
k_ENB	<- 0.675 #experienced non breeding
k_ES	<- 0.500 #experienced successful
k_IF	<- 0.627 #inexperienced failed
k_Imm	<- 0.585 #immature
k_IS	<- 0.627 #inexperienced successful
k_PF	<- 0.791 #sabbatical 

#return prob
r_EF	<- 0.973 #experienced failed
r_ENB	<- 0.953 #experienced non breeding
r_ES	<- 0.292 #experienced successful
r_IF	<- 0.948 #inexperienced failed
r_Imm	<- 0.692 #immature
r_IS	<- 0.459 #inexperienced successful
r_PF	<- 0.972 #sabbatical 

#survival
s_EF	<- 0.913 #experienced failed
s_ENB	<- 0.943 #experienced non breeding
s_ES	<- 0.895 #experienced successful
s_IF	<- 0.920 #inexperienced failed
s_Imm	<- 0.921 #immature
s_IS	<- 0.892 #inexperienced successful
s_Juv	<- 0.846 #juvenile
s_PF	<- 0.935 #sabbatical        


#mean VRs
mean_a_s <- (s_EF + s_ENB+ s_ES + s_IF + s_IS + s_PF)/6
mean_a_r <- (r_EF + r_ENB+ r_ES + r_IF + r_IS + r_PF)/6
mean_a_k <- (k_EF + k_ENB+ k_ES + k_IF + k_IS + k_PF)/6
mean_a_b <- (b_EF + b_ENB+ b_ES + b_IF + b_IS + b_PF)/6

#mean VRs
mean_s <- (s_EF + s_ENB+ s_ES + s_IF + s_IS + s_PF )/6
mean_r <- (r_EF + r_ENB+ r_ES + r_IF + r_IS + r_PF + r_Imm)/7
mean_k <- (k_EF + k_ENB+ k_ES + k_IF + k_IS + k_PF + k_Imm)/7
mean_b <- (b_EF + b_ENB+ b_ES + b_IF + b_IS + b_PF + b_Imm)/7
``` 

**create matrix**
```{r}
#Stages          #J2	 J3    Imm4  Imm5  PB	                                   IS                      IF    	                 ES	                     EF    	                 ENB	                       Sabb
m<-matrix(data=c(0,    0,	   0,	   0,	   0,	                                   0.5*s_Juv,              0,	                     0.5*s_Juv,	             0,	                     0,	                         0,                      #J2
                 s_Juv,0,	   0,	   0,	   0,                                 	 0,	                     0,	                     0,	                     0,	                     0,	                         0,                      #J3
	               0,	   s_Juv,0,	   0,	   0,	                                   0,	                     0,	                     0,	                     0,	                     0,	                         0,                      #Imm4
	               0,	   0,	   s_Imm,0,	   0,	                                   0,	                     0,	                     0,	                     0,	                     0,                          0,                      #Imm5
                 0,    0,	   0,	   s_Imm,s_Imm*r_Imm*(1-b_Imm)+s_Imm*(1-r_Imm),0,	                     0,	                     0,                      0,	                     0,	                         0,                      #PB
	               0,	   0,	   0,	   0,	   s_Imm*r_Imm*b_Imm*k_Imm,	             0,	                     0,	                     0,	                     0,	                     0,	                         0,                      #IS
	               0,    0,	   0,	   0,	   s_Imm*r_Imm*b_Imm*(1-k_Imm),	         0,	                     0,	                     0,	                     0,	                     0,	                         0,                      #IF
	               0,	   0,	   0,	   0,	   0,	                                   s_IS*r_IS*b_IS*k_IS,    s_IF*r_IF*b_IF*k_IF,	   s_ES*r_ES*b_ES*k_ES,	   s_EF*r_EF*b_EF*k_EF,	   s_ENB*r_ENB*b_ENB*k_ENB,	   s_PF*r_PF*b_PF*k_PF,    #ES
                 0,	   0,	   0,	   0,	   0,	                                   s_IS*r_IS*b_IS*(1-k_IS),s_IF*r_IF*b_IF*(1-k_IF),s_ES*r_ES*b_ES*(1-k_ES),s_EF*r_EF*b_EF*(1-k_EF),s_ENB*r_ENB*b_ENB*(1-k_ENB),s_PF*r_PF*b_PF*(1-k_PF),#EF
	               0,	   0,	   0,	   0,	   0,	                                   s_IS*r_IS*(1-b_IS),	   s_IF*r_IF*(1-b_IF),	   s_ES*r_ES*(1-b_ES),	   s_EF*r_EF*(1-b_EF),	   s_ENB*r_ENB*(1-b_ENB),	     s_PF*r_PF*(1-b_PF),     #ENB
	               0,    0,	   0,	   0,	   0,	                                   s_IS*(1-r_IS),	         s_IF*(1-r_IF),	         s_ES*(1-r_ES),	         s_EF*(1-r_EF),	         s_ENB*(1-r_ENB),	           s_PF*(1-r_PF) ),        #Sabb
	               nrow = 11, byrow = TRUE)
m
```

**extract lambda, SSDs, and RVs from eigenvalues**
```{r}
#deterministic growth rate (lambda)
#extract eigenvalues and lambda from the matrix 
m_eig <- eigen(m)
lambda <- as.numeric(m_eig$values[1])
lambda # 0.9749412 - this looks reasonable compared to Pardo's figure. Just a guess-timate since she doesn't report a mean lambda across all years

#Stable state distribution
#extract and scale the right eigenvector 
SSD <- round(as.numeric(m_eig$vectors[,1]/sum(m_eig$vectors[,1])),3)
SSD

#extract reproductive values
RV <- as.numeric(eigen(t(m))$vectors[,1]/eigen(t(m))$vectors[1,1])
RV
```

**Compare SSD to observed demographic proportions from Clay et al.**
```{r}
# Matrix stage names (matching column order)
stage_names <- c("J2", "J3", "Imm4", "Imm5", "PB", "IS", "IF", "ES", "EF", "ENB", "Sabb")
names(SSD) <- stage_names

# Map matrix stages to Clay demographic classes
# FB = failed breeders (IF + EF)
# SB = successful breeders (IS + ES)
# NB = non-breeders (ENB + Sabb)
# J2J3 = juveniles (J2 + J3)
# IMM = immatures (Imm4 + Imm5 + PB)
ssd_grouped <- tibble(
  Dem_class = c("J2J3", "IMM", "FB", "SB", "NB"),
  ssd_prop = c(
    SSD["J2"] + SSD["J3"],
    SSD["Imm4"] + SSD["Imm5"] + SSD["PB"],
    SSD["IF"] + SSD["EF"],
    SSD["IS"] + SSD["ES"],
    SSD["ENB"] + SSD["Sabb"]
  )
)

# Load observed proportions from Clay (excluding J1 and summary row)
dem_props_obs <- read_csv(here("data/WAAL_dist_Clay2019/Dem_props copy.csv"),
                          show_col_types = FALSE) %>%
  mutate(Dem_class = str_replace(Dem_class, "J2\\+3", "J2J3")) %>%
  filter(Dem_class != "J1", Period != "1990-2009")

# Mean observed proportion across periods
obs_mean <- dem_props_obs %>%
  group_by(Dem_class) %>%
  summarise(obs_prop = mean(Prop), .groups = "drop")

# Renormalize observed proportions to sum to 1 (since J1 is excluded)
obs_mean <- obs_mean %>%
  mutate(obs_prop_norm = obs_prop / sum(obs_prop))

# Compare SSD vs observed
comparison <- ssd_grouped %>%
  left_join(obs_mean, by = "Dem_class") %>%
  mutate(
    ssd_norm = ssd_prop / sum(ssd_prop),
    difference = ssd_norm - obs_prop_norm,
    ratio = round(ssd_norm / obs_prop_norm, 3)
  )

comparison %>%
  mutate(across(where(is.numeric), ~round(.x, 4))) %>%
  print()

# Also show how proportions changed over time (population not at SSD)
dem_props_obs %>%
  select(Period, Dem_class, Prop) %>%
  pivot_wider(names_from = Period, values_from = Prop) %>%
  left_join(ssd_grouped %>% select(Dem_class, ssd_prop), by = "Dem_class") %>%
  mutate(across(where(is.numeric), ~round(.x, 4))) %>%
  print()
```
*LOAD BYCATCH MORTALITY FROM SCRIPT 03f*

Fishing effort, bird distributions, spatial overlap, and BPUE estimation are all handled in script 03f (spatial catchability approach). Here we load the mean annual per-capita bycatch rates and use them in the demographic model.

**load per-capita bycatch rates from 03f (1990-1995 period)**
```{r}
# Load period-specific bycatch totals from 03f
byc_period <- read_csv(here("output/bycatch_by_fishery_period_03f.csv"), show_col_types = FALSE)

# Load period-specific population sizes from Clay demographic data
dem_props <- read_csv(here("data/WAAL_dist_Clay2019/Dem_props copy.csv"),
                      show_col_types = FALSE) %>%
  mutate(Dem_class = str_replace(Dem_class, "J2\\+3", "J2J3"))

# Use 1990-1995 bycatch with 1990-1994 population (closest matching period)
target_period_byc <- "1990-1995"
target_period_pop <- "1990-1994"

pop_1990 <- dem_props %>%
  filter(Period == target_period_pop, Dem_class != "J1") %>%
  select(Dem_class, Pop) %>%
  mutate(age_class = tolower(Dem_class)) %>%
  mutate(age_class = case_when(
    age_class == "j2j3" ~ "j2j3",
    age_class == "imm" ~ "imm",
    age_class == "fb" ~ "fb",
    age_class == "sb" ~ "sb",
    age_class == "nb" ~ "nb"
  ))

# Get 1990-1995 bycatch by fishery and calculate per-capita
byc_1990 <- byc_period %>%
  filter(year_group == target_period_byc) %>%
  select(fishery, fb, sb, nb, j2j3, imm) %>%
  pivot_longer(cols = c(fb, sb, nb, j2j3, imm), names_to = "age_class", values_to = "annual_byc") %>%
  left_join(pop_1990 %>% select(age_class, Pop), by = "age_class") %>%
  mutate(percap = annual_byc / Pop)

byc_1990 %>% print(n = 20)

# Extract per-capita rates by fishery and age class
dem_fm_juv <- byc_1990 %>% filter(fishery == "DLL", age_class == "j2j3") %>% pull(percap)
dem_fm_imm <- byc_1990 %>% filter(fishery == "DLL", age_class == "imm") %>% pull(percap)
dem_fm_fb  <- byc_1990 %>% filter(fishery == "DLL", age_class == "fb") %>% pull(percap)
dem_fm_sb  <- byc_1990 %>% filter(fishery == "DLL", age_class == "sb") %>% pull(percap)
dem_fm_nb  <- byc_1990 %>% filter(fishery == "DLL", age_class == "nb") %>% pull(percap)

pel_fm_juv <- byc_1990 %>% filter(fishery == "PLL", age_class == "j2j3") %>% pull(percap)
pel_fm_imm <- byc_1990 %>% filter(fishery == "PLL", age_class == "imm") %>% pull(percap)
pel_fm_fb  <- byc_1990 %>% filter(fishery == "PLL", age_class == "fb") %>% pull(percap)
pel_fm_sb  <- byc_1990 %>% filter(fishery == "PLL", age_class == "sb") %>% pull(percap)
pel_fm_nb  <- byc_1990 %>% filter(fishery == "PLL", age_class == "nb") %>% pull(percap)

# Print summary
cat(sprintf("=== Per-capita fishing mortality (%s bycatch, %s population) ===\n\n",
            target_period_byc, target_period_pop))
cat(sprintf("%-8s %10s %10s %10s\n", "Age", "DLL", "PLL", "Total"))
for (ac in c("j2j3", "imm", "fb", "sb", "nb")) {
  d <- byc_1990 %>% filter(fishery == "DLL", age_class == ac) %>% pull(percap)
  p <- byc_1990 %>% filter(fishery == "PLL", age_class == ac) %>% pull(percap)
  cat(sprintf("%-8s %10.6f %10.6f %10.6f\n", ac, d, p, d + p))
}
```

**IUU**
Welch et al (6%), Weimerskirch et al. (=< 33%), Carneiro et al. 2022 (low, need to calculate myself from her paper)
USE THESE RATES TO SET IUU scenarios, distributions as in previous code


**partition mortality between natural and fishery mortality, set efficacy rates**
```{r}
# survival = 1 - total_mortality
# total_mortality = natural_mortality + fishing_mortality
# therefore: natural_mortality = (1 - survival) - fishing_mortality

# Natural mortality = total mortality minus fishing mortality (no IUU)
nm_juv <- (1-s_Juv)-dem_fm_juv-pel_fm_juv
nm_imm <- (1-s_Imm)-dem_fm_imm-pel_fm_imm
nm_efb <- (1-s_EF)-dem_fm_fb-pel_fm_fb
nm_esb <- (1-s_ES)-dem_fm_sb-pel_fm_sb
nm_enb <- (1-s_ENB)-dem_fm_nb-pel_fm_nb
nm_ifb <- (1-s_IF)-dem_fm_fb-pel_fm_fb
nm_isb <- (1-s_IS)-dem_fm_sb-pel_fm_sb
nm_pf  <- (1-s_PF)-dem_fm_nb-pel_fm_nb

# Check all natural mortalities are positive
cat("=== Natural mortality check ===\n")
nm_vals <- c(nm_juv=nm_juv, nm_imm=nm_imm, nm_efb=nm_efb, nm_esb=nm_esb,
             nm_enb=nm_enb, nm_ifb=nm_ifb, nm_isb=nm_isb, nm_pf=nm_pf)
for (nm_name in names(nm_vals)) {
  cat(sprintf("  %s: %.4f %s\n", nm_name, nm_vals[nm_name],
              ifelse(nm_vals[nm_name] > 0, "OK", "NEGATIVE - bycatch too high!")))
}
```

**loop through different bycatch reductions scenarios, find lambda for each**
this assumes 80% reduction in bycatch through mitigation
this assumes that demersal and pelagic LL are reduced at the same rate and efficacy
FUTURE SCENARIOS need to be based on specific management scenarios (2/3 vs 3/3, reductions in specific RFMOs, etc, based on what % of hooks different management blocks account for, then I can modify bycatch on certain proportions of fishing effort) - 
this (below) is just a very basic way to test as a starting point - continuous looking at % of fishing effort subject to mitigation vs different rates of efficacy
```{r}
mitigation_eff <- 0.8
bycatch_reductions <- data.frame(reduction = seq(0, 1, by =0.01), lambda = NA)

for(i in 1:nrow(bycatch_reductions)){

  
  #   n_s_j <- 1-((fm*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_j))
  # n_s_i <- 1-((fm*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_i))
  # n_s_s <- 1-((fm*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_s))
  # n_s_a <- 1-((fm*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_s))
  # 
  
  ns_Juv <- 1-(((dem_fm_juv+pel_fm_juv)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_juv))
  #ns_Juv <- 1-(((dem_fm_juv)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(((pel_fm_juv)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_juv)) - this is baseline to start manipulating differences separately
  # further partition by % of each fishery - ex: atlantic basin = 75% pel effort abd 40% demersal effort they are exposed to - further partition 75/25 pel and 40/60 dem and only modify the section changing (here, atlantic basin)
  # another way - 2/3 and 3/3 (how effective are each from the literature?) - test blanket adoption of both AND TEST what management areas recommend which and test this 
  ns_Imm <- 1-(((dem_fm_imm+pel_fm_imm)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_imm))
  ns_EF <- 1-(((dem_fm_fb+pel_fm_fb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_efb))
  ns_ES <- 1-(((dem_fm_sb+pel_fm_sb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_esb))
  ns_ENB <- 1-(((dem_fm_nb+pel_fm_nb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_enb))
  ns_IF <- 1-(((dem_fm_fb+pel_fm_fb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_ifb))
  ns_IS <- 1-(((dem_fm_sb+pel_fm_sb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_isb))
  ns_PF  <- 1-(((dem_fm_nb+pel_fm_nb)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_pf))
  
#Stages            #J2	  J3     Imm4   Imm5   PB	                                     IS                       IF    	                 ES	                      EF    	                 ENB	                        Sabb
n_m<-matrix(data=c(0,     0,	   0,	    0,	   0,	                                     0.5*ns_Juv,              0,	                     0.5*ns_Juv,	            0,	                     0,	                          0,                       #J2
                   ns_Juv,0,	   0,	    0,	   0,                                 	   0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #J3
	                 0,	    ns_Juv,0,	    0,	   0,	                                     0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #Imm4
	                 0,	    0,	   ns_Imm,0,	   0,	                                     0,	                      0,	                     0,	                      0,	                     0,                           0,                       #Imm5
                   0,     0,	   0,	    ns_Imm,ns_Imm*r_Imm*(1-b_Imm)+ns_Imm*(1-r_Imm),0,	                      0,	                     0,                       0,	                     0,	                          0,                       #PB
	                 0,	    0,	   0,	    0,	   ns_Imm*r_Imm*b_Imm*k_Imm,	             0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #IS
	                 0,     0,	   0,	    0,	   ns_Imm*r_Imm*b_Imm*(1-k_Imm),	         0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #IF
	                 0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*b_IS*k_IS,    ns_IF*r_IF*b_IF*k_IF,	   ns_ES*r_ES*b_ES*k_ES,	  ns_EF*r_EF*b_EF*k_EF,	   ns_ENB*r_ENB*b_ENB*k_ENB,	  ns_PF*r_PF*b_PF*k_PF,    #ES
                   0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*b_IS*(1-k_IS),ns_IF*r_IF*b_IF*(1-k_IF),ns_ES*r_ES*b_ES*(1-k_ES),ns_EF*r_EF*b_EF*(1-k_EF),ns_ENB*r_ENB*b_ENB*(1-k_ENB),ns_PF*r_PF*b_PF*(1-k_PF),#EF
	                 0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*(1-b_IS),	    ns_IF*r_IF*(1-b_IF),	   ns_ES*r_ES*(1-b_ES),	    ns_EF*r_EF*(1-b_EF),	   ns_ENB*r_ENB*(1-b_ENB),	    ns_PF*r_PF*(1-b_PF),     #ENB
	                 0,     0,	   0,	    0,	   0,	                                     ns_IS*(1-r_IS),	        ns_IF*(1-r_IF),	         ns_ES*(1-r_ES),	        ns_EF*(1-r_EF),	         ns_ENB*(1-r_ENB),	          ns_PF*(1-r_PF) ),        #Sabb
	               nrow = 11, byrow = TRUE)
n_m
  
  #extract eigenvalues and lambda from the matrix 
  n_m_eig <- eigen(n_m)
  lambda_n <- as.numeric(n_m_eig$values[1])
  bycatch_reductions$lambda[i] <- lambda_n 

}
```

**plot bycatch reduction against changes to lambda**
```{r}
ggplot(bycatch_reductions)+
  geom_line(aes(x=reduction, y=as.numeric(lambda)))+
  geom_hline(aes(yintercept = 1), color = "red", alpha =0.5)+ 
  # geom_vline(aes(xintercept = 0.66), color = "red", alpha =0.5)+ #illegal vs legal fisheries transition
  # geom_vline(aes(xintercept = 0.33), color = "red", alpha =0.5)+ #illegal vs legal fisheries transition
  labs(x="% fisheries with bycatch mitigation", y="lambda")+
  themeo+
  coord_cartesian(expand=FALSE)
```

**add uncertainty for mitigation efficacy**
```{r}
bycatch_reductions2 <- seq(0, 1, by =0.01)
mitigation_eff_range <- seq(0.5,1, by  = 0.1)
output <- matrix(nrow = length(bycatch_reductions2), ncol = length(mitigation_eff_range)) %>% as.data.frame() 

for(k in 1:length(mitigation_eff_range)){
  mit_eff <- mitigation_eff_range[k]
  
  for(i in 1:length(bycatch_reductions2)){

 ns_Juv <- 1-(((dem_fm_juv+pel_fm_juv)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_juv))
  #ns_Juv <- 1-(((dem_fm_juv)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(((pel_fm_juv)*(1-(mitigation_eff*bycatch_reductions$reduction[i])))+(nm_juv)) - this is baseline to start manipulating differences separately
  # further partition by % of each fishery - ex: atlantic basin = 75% pel effort abd 40% demersal effort they are exposed to - further partition 75/25 pel and 40/60 dem and only modify the section changing (here, atlantic basin)
  # another way - 2/3 and 3/3 (how effective are each from the literature?) - test blanket adoption of both AND TEST what management areas recommend which and test this 
  ns_Imm <- 1-(((dem_fm_imm+pel_fm_imm)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_imm))
  ns_EF <- 1-(((dem_fm_fb+pel_fm_fb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_efb))
  ns_ES <- 1-(((dem_fm_sb+pel_fm_sb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_esb))
  ns_ENB <- 1-(((dem_fm_nb+pel_fm_nb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_enb))
  ns_IF <- 1-(((dem_fm_fb+pel_fm_fb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_ifb))
  ns_IS <- 1-(((dem_fm_sb+pel_fm_sb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_isb))
  ns_PF  <- 1-(((dem_fm_nb+pel_fm_nb)*(1-(mit_eff*bycatch_reductions$reduction[i])))+(nm_pf))
  
#Stages            #J2	  J3     Imm4   Imm5   PB	                                     IS                       IF    	                 ES	                      EF    	                 ENB	                        Sabb
n_m<-matrix(data=c(0,     0,	   0,	    0,	   0,	                                     0.5*ns_Juv,              0,	                     0.5*ns_Juv,	            0,	                     0,	                          0,                       #J2
                   ns_Juv,0,	   0,	    0,	   0,                                 	   0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #J3
	                 0,	    ns_Juv,0,	    0,	   0,	                                     0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #Imm4
	                 0,	    0,	   ns_Imm,0,	   0,	                                     0,	                      0,	                     0,	                      0,	                     0,                           0,                       #Imm5
                   0,     0,	   0,	    ns_Imm,ns_Imm*r_Imm*(1-b_Imm)+ns_Imm*(1-r_Imm),0,	                      0,	                     0,                       0,	                     0,	                          0,                       #PB
	                 0,	    0,	   0,	    0,	   ns_Imm*r_Imm*b_Imm*k_Imm,	             0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #IS
	                 0,     0,	   0,	    0,	   ns_Imm*r_Imm*b_Imm*(1-k_Imm),	         0,	                      0,	                     0,	                      0,	                     0,	                          0,                       #IF
	                 0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*b_IS*k_IS,    ns_IF*r_IF*b_IF*k_IF,	   ns_ES*r_ES*b_ES*k_ES,	  ns_EF*r_EF*b_EF*k_EF,	   ns_ENB*r_ENB*b_ENB*k_ENB,	  ns_PF*r_PF*b_PF*k_PF,    #ES
                   0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*b_IS*(1-k_IS),ns_IF*r_IF*b_IF*(1-k_IF),ns_ES*r_ES*b_ES*(1-k_ES),ns_EF*r_EF*b_EF*(1-k_EF),ns_ENB*r_ENB*b_ENB*(1-k_ENB),ns_PF*r_PF*b_PF*(1-k_PF),#EF
	                 0,	    0,	   0,	    0,	   0,	                                     ns_IS*r_IS*(1-b_IS),	    ns_IF*r_IF*(1-b_IF),	   ns_ES*r_ES*(1-b_ES),	    ns_EF*r_EF*(1-b_EF),	   ns_ENB*r_ENB*(1-b_ENB),	    ns_PF*r_PF*(1-b_PF),     #ENB
	                 0,     0,	   0,	    0,	   0,	                                     ns_IS*(1-r_IS),	        ns_IF*(1-r_IF),	         ns_ES*(1-r_ES),	        ns_EF*(1-r_EF),	         ns_ENB*(1-r_ENB),	          ns_PF*(1-r_PF) ),        #Sabb
	               nrow = 11, byrow = TRUE)
n_m
  
  #extract eigenvalues and lambda from the matrix 
 #extract eigenvalues and lambda from the matrix 
  n_m_eig <- eigen(n_m)
  lambda_n <- as.numeric(n_m_eig$values[1])
  output[i,k] <- lambda_n # this matches the ideal population growth rate in the table

}
}

```

*format output*
```{r}
oldnames = c("V1","V2","V3","V4" ,"V5", "V6")
newnames = c("0.5", "0.6", "0.7", "0.8", "0.9", "1")

output<- output %>%
  rename_with(~ newnames[which(oldnames == .x)], .cols = oldnames)

output$bycatch_reductions <- bycatch_reductions2

output_l <- output %>% 
  pivot_longer(cols = !bycatch_reductions,names_to = "mit_eff", values_to = "lambda")

output_l$mit_eff <- as.numeric(output_l$mit_eff)
```


```{r}
ggplot(output_l)+
  geom_line(aes(x=bycatch_reductions, y=lambda, group = factor(mit_eff), color = factor(mit_eff)))+
  geom_hline(aes(yintercept = 1), color = "darkgrey", alpha =0.5)+ 
  # geom_vline(aes(xintercept = 0.66), color = "red", alpha =0.5)+ #illegal vs legal fisheries transition
  # geom_vline(aes(xintercept = 0.33), color = "red", alpha =0.5)+ #illegal vs legal fisheries transition
  labs(x="% fisheries with bycatch mitigation", y="lambda", color = "% mitigation efficacy")+
  themeo+
  guides(colour = guide_legend(nrow = 1))+
  coord_cartesian(expand=FALSE)+
  scale_color_manual(values=c("#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494"))
```

*FLEET-LEVEL MITIGATION SCENARIOS*

The blanket approach above applies uniform mitigation across all fisheries. Below we disaggregate bycatch by fleet and apply fleet-specific mitigation reflecting actual management practices.

**load fleet-level bycatch and define mitigation scenarios**
```{r}
# Load fleet-level bycatch for the baseline period (1990-1995)
fleet_byc <- read_csv(here("output/bycatch_by_fleet_period_03f.csv"), show_col_types = FALSE) %>%
  filter(year_group == "1990-1995")

# Calculate per-capita rates by fleet
fleet_percap <- fleet_byc %>%
  select(fishery, fleet, fb, sb, nb, j2j3, imm) %>%
  pivot_longer(cols = c(fb, sb, nb, j2j3, imm), names_to = "age_class", values_to = "byc") %>%
  left_join(pop_1990 %>% select(age_class, Pop), by = "age_class") %>%
  mutate(percap = byc / Pop)

# Show which fleets contribute most to bycatch
fleet_byc %>%
  select(fishery, fleet, bi_total) %>%
  arrange(desc(bi_total)) %>%
  print(n = 20)
```

**define mitigation efficacy rates (PLACEHOLDERS - update from literature)**
```{r}
# Efficacy of different mitigation measures (proportion reduction in bycatch)
# These are placeholders — replace with literature values
eff_tori_lines   <- 0.70  # tori/bird scaring lines
eff_night_set    <- 0.60  # night setting
eff_line_weight  <- 0.50  # weighted branch lines / integrated weight lines
eff_hook_shield  <- 0.40  # hook shielding devices / smart tuna hooks

# Combined efficacy: 1 - (1-a)*(1-b)*(1-c) for independent measures
eff_2of3 <- 1 - (1 - eff_tori_lines) * (1 - eff_night_set)                    # tori + night set
eff_3of3 <- 1 - (1 - eff_tori_lines) * (1 - eff_night_set) * (1 - eff_line_weight)  # all three

cat(sprintf("2/3 combined efficacy: %.1f%%\n", eff_2of3 * 100))
cat(sprintf("3/3 combined efficacy: %.1f%%\n", eff_3of3 * 100))
```

**define fleet-level mitigation status**
```{r}
# Define current mitigation status for each fleet
# status: "none", "partial" (2/3 measures), "full" (3/3 measures, best practice)
# compliance: proportion of fleet actually using the measures (0-1)
# PLACEHOLDERS — update based on RFMO/fleet-specific information

fleet_mitigation <- tribble(
  ~fishery, ~fleet,          ~status,    ~compliance,  ~notes,
  # DLL fleets - many have strong mitigation (CCAMLR especially)
  "DLL",    "CCAMLR",        "full",     0.95,         "3/3 measures, strong enforcement",
  "DLL",    "Argentina",     "partial",  0.70,         "some measures adopted",
  "DLL",    "Chile",         "partial",  0.60,         "some measures adopted",
  "DLL",    "Falklands",     "full",     0.90,         "3/3 measures, good compliance",
  "DLL",    "South Africa",  "full",     0.85,         "3/3 measures",
  # PLL fleets - many have 2/3 or less
  "PLL",    "Japan",         "partial",  0.80,         "2/3 in most RFMOs",
  "PLL",    "Taiwan",        "partial",  0.60,         "2/3 adopted but variable compliance",
  "PLL",    "Korea",         "partial",  0.50,         "2/3 in some areas",
  "PLL",    "Spain",         "partial",  0.70,         "EU requirements, 2/3",
  "PLL",    "Portugal",      "partial",  0.70,         "EU requirements, 2/3",
  "PLL",    "Brazil",        "partial",  0.40,         "some measures, lower compliance",
  "PLL",    "China",         "none",     0.0,          "limited adoption",
  "PLL",    "Other",         "none",     0.0,          "mixed/unknown fleets",
  "PLL",    "Chile",         "partial",  0.60,         "some measures",
  "PLL",    "South Africa",  "partial",  0.70,         "domestic requirements",
  "PLL",    "Cuba",          "none",     0.0,          "no information",
  "PLL",    "Belize",        "none",     0.0,          "flag of convenience",
  "PLL",    "France Reunion", "partial", 0.60,         "EU requirements",
  "PLL",    "Seychelles",    "none",     0.0,          "limited adoption",
  "PLL",    "Namibia",       "partial",  0.50,         "some measures",
  "PLL",    "Vanuatu",       "none",     0.0,          "flag of convenience",
  "PLL",    "USSR",          "none",     0.0,          "historical, no mitigation",
  "PLL",    "USA",           "partial",  0.80,         "NMFS requirements",
  "PLL",    "Panama",        "none",     0.0,          "flag of convenience",
  "PLL",    "French Polynesia","partial",0.60,         "EU/French requirements",
  "PLL",    "St. Vincent and Grenadines", "none", 0.0, "flag of convenience"
)

# Map status to efficacy
fleet_mitigation <- fleet_mitigation %>%
  mutate(
    base_efficacy = case_when(
      status == "full"    ~ eff_3of3,
      status == "partial" ~ eff_2of3,
      status == "none"    ~ 0
    ),
    # Effective reduction = base efficacy * compliance
    effective_reduction = base_efficacy * compliance
  )

fleet_mitigation %>%
  select(fishery, fleet, status, compliance, base_efficacy, effective_reduction) %>%
  arrange(fishery, desc(effective_reduction)) %>%
  print(n = 30)
```

**calculate fleet-level fishing mortality under different scenarios**
```{r}
# Function to calculate total fishing mortality per age class under a given scenario
# scenario = a fleet_mitigation-style dataframe with effective_reduction per fleet
calc_fleet_fm <- function(fleet_percap_df, scenario_df) {

  # Join fleet per-capita rates with scenario reductions
  fm_by_fleet <- fleet_percap_df %>%
    left_join(scenario_df %>% select(fishery, fleet, effective_reduction),
              by = c("fishery", "fleet")) %>%
    mutate(
      # If fleet not in scenario table, assume no mitigation
      effective_reduction = replace_na(effective_reduction, 0),
      # Reduced per-capita rate
      percap_mitigated = percap * (1 - effective_reduction)
    )

  # Sum across fleets within each fishery x age_class
  fm_by_fishery <- fm_by_fleet %>%
    group_by(fishery, age_class) %>%
    summarise(
      percap_baseline = sum(percap),
      percap_mitigated = sum(percap_mitigated),
      pct_reduction = 1 - percap_mitigated / percap_baseline,
      .groups = "drop"
    )

  fm_by_fishery
}

# Helper to extract fm values from scenario output and build matrix
calc_lambda_from_scenario <- function(scenario_fm) {

  # Extract mitigated per-capita rates
  get_fm <- function(fish, ac) {
    scenario_fm %>% filter(fishery == fish, age_class == ac) %>% pull(percap_mitigated)
  }

  s_dem_fm_juv <- get_fm("DLL", "j2j3"); s_pel_fm_juv <- get_fm("PLL", "j2j3")
  s_dem_fm_imm <- get_fm("DLL", "imm");  s_pel_fm_imm <- get_fm("PLL", "imm")
  s_dem_fm_fb  <- get_fm("DLL", "fb");   s_pel_fm_fb  <- get_fm("PLL", "fb")
  s_dem_fm_sb  <- get_fm("DLL", "sb");   s_pel_fm_sb  <- get_fm("PLL", "sb")
  s_dem_fm_nb  <- get_fm("DLL", "nb");   s_pel_fm_nb  <- get_fm("PLL", "nb")

  # New survival = 1 - natural_mortality - mitigated_fishing_mortality
  ns_Juv <- 1 - nm_juv - s_dem_fm_juv - s_pel_fm_juv
  ns_Imm <- 1 - nm_imm - s_dem_fm_imm - s_pel_fm_imm
  ns_EF  <- 1 - nm_efb - s_dem_fm_fb  - s_pel_fm_fb
  ns_IF  <- 1 - nm_ifb - s_dem_fm_fb  - s_pel_fm_fb
  ns_ES  <- 1 - nm_esb - s_dem_fm_sb  - s_pel_fm_sb
  ns_IS  <- 1 - nm_isb - s_dem_fm_sb  - s_pel_fm_sb
  ns_ENB <- 1 - nm_enb - s_dem_fm_nb  - s_pel_fm_nb
  ns_PF  <- 1 - nm_pf  - s_dem_fm_nb  - s_pel_fm_nb

  # Build matrix (same structure as baseline)
  n_m <- matrix(data = c(
    0,     0,     0,      0,      0,                                           0.5*ns_Juv,              0,                       0.5*ns_Juv,              0,                       0,                         0,
    ns_Juv,0,     0,      0,      0,                                           0,                       0,                       0,                       0,                       0,                         0,
    0,     ns_Juv,0,      0,      0,                                           0,                       0,                       0,                       0,                       0,                         0,
    0,     0,     ns_Imm, 0,      0,                                           0,                       0,                       0,                       0,                       0,                         0,
    0,     0,     0,      ns_Imm, ns_Imm*r_Imm*(1-b_Imm)+ns_Imm*(1-r_Imm),   0,                       0,                       0,                       0,                       0,                         0,
    0,     0,     0,      0,      ns_Imm*r_Imm*b_Imm*k_Imm,                   0,                       0,                       0,                       0,                       0,                         0,
    0,     0,     0,      0,      ns_Imm*r_Imm*b_Imm*(1-k_Imm),               0,                       0,                       0,                       0,                       0,                         0,
    0,     0,     0,      0,      0,                                           ns_IS*r_IS*b_IS*k_IS,    ns_IF*r_IF*b_IF*k_IF,    ns_ES*r_ES*b_ES*k_ES,    ns_EF*r_EF*b_EF*k_EF,    ns_ENB*r_ENB*b_ENB*k_ENB,  ns_PF*r_PF*b_PF*k_PF,
    0,     0,     0,      0,      0,                                           ns_IS*r_IS*b_IS*(1-k_IS),ns_IF*r_IF*b_IF*(1-k_IF),ns_ES*r_ES*b_ES*(1-k_ES),ns_EF*r_EF*b_EF*(1-k_EF),ns_ENB*r_ENB*b_ENB*(1-k_ENB),ns_PF*r_PF*b_PF*(1-k_PF),
    0,     0,     0,      0,      0,                                           ns_IS*r_IS*(1-b_IS),     ns_IF*r_IF*(1-b_IF),     ns_ES*r_ES*(1-b_ES),     ns_EF*r_EF*(1-b_EF),     ns_ENB*r_ENB*(1-b_ENB),    ns_PF*r_PF*(1-b_PF),
    0,     0,     0,      0,      0,                                           ns_IS*(1-r_IS),          ns_IF*(1-r_IF),          ns_ES*(1-r_ES),          ns_EF*(1-r_EF),          ns_ENB*(1-r_ENB),          ns_PF*(1-r_PF)
  ), nrow = 11, byrow = TRUE)

  # Extract lambda
  n_m_eig <- eigen(n_m)
  lambda_n <- as.numeric(n_m_eig$values[1])

  return(lambda_n)
}
```

**define and run management scenarios**
```{r}
# SCENARIO 0: No mitigation (baseline 1990-1995)
scenario_none <- fleet_mitigation %>%
  mutate(effective_reduction = 0)

# SCENARIO 1: Current mitigation (as defined in fleet_mitigation table above)
scenario_current <- fleet_mitigation

# SCENARIO 2: All PLL fleets adopt 2/3 (current compliance levels)
scenario_pll_2of3 <- fleet_mitigation %>%
  mutate(
    base_efficacy = case_when(
      fishery == "DLL" ~ base_efficacy,  # keep DLL as is
      TRUE ~ eff_2of3                     # all PLL get 2/3
    ),
    compliance = case_when(
      fishery == "DLL" ~ compliance,
      compliance == 0 ~ 0.50,             # fleets with no mitigation get 50% compliance
      TRUE ~ compliance                   # keep existing compliance
    ),
    effective_reduction = base_efficacy * compliance
  )

# SCENARIO 3: All PLL fleets adopt 3/3 (current compliance levels)
scenario_pll_3of3 <- fleet_mitigation %>%
  mutate(
    base_efficacy = case_when(
      fishery == "DLL" ~ base_efficacy,
      TRUE ~ eff_3of3
    ),
    compliance = case_when(
      fishery == "DLL" ~ compliance,
      compliance == 0 ~ 0.50,
      TRUE ~ compliance
    ),
    effective_reduction = base_efficacy * compliance
  )

# SCENARIO 4: Full compliance everywhere (3/3, 100% compliance)
scenario_full <- fleet_mitigation %>%
  mutate(
    base_efficacy = eff_3of3,
    compliance = 1.0,
    effective_reduction = base_efficacy * compliance
  )

# SCENARIO 5: Target top 3 PLL fleets only (Taiwan, Japan, Other = ~95% of PLL bycatch)
# These are the fleets where intervention would have the most impact
scenario_target_top3 <- fleet_mitigation %>%
  mutate(
    base_efficacy = case_when(
      fishery == "PLL" & fleet %in% c("Taiwan", "Japan", "Other") ~ eff_3of3,
      TRUE ~ base_efficacy
    ),
    compliance = case_when(
      fishery == "PLL" & fleet %in% c("Taiwan", "Japan", "Other") ~ 0.80,
      TRUE ~ compliance
    ),
    effective_reduction = base_efficacy * compliance
  )

# Run all scenarios
scenarios <- list(
  "0_no_mitigation"    = scenario_none,
  "1_current"          = scenario_current,
  "2_all_pll_2of3"     = scenario_pll_2of3,
  "3_all_pll_3of3"     = scenario_pll_3of3,
  "4_full_compliance"  = scenario_full,
  "5_target_top3_pll"  = scenario_target_top3
)

scenario_results <- tibble(
  scenario = names(scenarios),
  lambda = NA_real_,
  dll_reduction_pct = NA_real_,
  pll_reduction_pct = NA_real_,
  total_byc_reduction_pct = NA_real_
)

for (i in seq_along(scenarios)) {
  fm <- calc_fleet_fm(fleet_percap, scenarios[[i]])
  scenario_results$lambda[i] <- calc_lambda_from_scenario(fm)

  # Track reductions
  dll_red <- fm %>% filter(fishery == "DLL") %>% summarise(mean(pct_reduction)) %>% pull()
  pll_red <- fm %>% filter(fishery == "PLL") %>% summarise(mean(pct_reduction)) %>% pull()
  total_red <- fm %>% summarise(
    weighted.mean(pct_reduction, w = percap_baseline)
  ) %>% pull()

  scenario_results$dll_reduction_pct[i] <- round(dll_red * 100, 1)
  scenario_results$pll_reduction_pct[i] <- round(pll_red * 100, 1)
  scenario_results$total_byc_reduction_pct[i] <- round(total_red * 100, 1)
}

scenario_results %>%
  mutate(lambda = round(lambda, 4)) %>%
  print()
```

**plot scenario comparison**
```{r}
ggplot(scenario_results, aes(x = reorder(scenario, lambda), y = lambda)) +
  geom_col(fill = "#41b6c4", width = 0.6) +
  geom_hline(yintercept = 1, color = "red", alpha = 0.5, linetype = "dashed") +
  geom_text(aes(label = round(lambda, 4)), hjust = -0.1, size = 3) +
  labs(x = "", y = "lambda",
       title = "Population growth rate under fleet-specific mitigation scenarios") +
  coord_flip(ylim = c(min(scenario_results$lambda) - 0.005, max(max(scenario_results$lambda) + 0.005, 1.005))) +
  themeo
```

**detailed fleet contribution to bycatch reduction**
```{r}
# Show which fleets contribute most to bycatch and how much each scenario reduces them
# Using scenario 5 (target top 3) as example
fm_target <- calc_fleet_fm(fleet_percap, scenario_target_top3)

# Fleet-level detail
fleet_detail <- fleet_percap %>%
  left_join(scenario_target_top3 %>% select(fishery, fleet, effective_reduction, status),
            by = c("fishery", "fleet")) %>%
  mutate(
    effective_reduction = replace_na(effective_reduction, 0),
    byc_mitigated = byc * (1 - effective_reduction)
  ) %>%
  group_by(fishery, fleet) %>%
  summarise(
    total_byc_baseline = sum(byc),
    total_byc_mitigated = sum(byc_mitigated),
    reduction_pct = round((1 - total_byc_mitigated / total_byc_baseline) * 100, 1),
    .groups = "drop"
  ) %>%
  filter(total_byc_baseline > 0.01) %>%
  arrange(desc(total_byc_baseline))

fleet_detail %>% print(n = 20)

cat(sprintf("\nTotal baseline bycatch: %.1f birds\n", sum(fleet_detail$total_byc_baseline)))
cat(sprintf("Total mitigated bycatch: %.1f birds\n", sum(fleet_detail$total_byc_mitigated)))
cat(sprintf("Overall reduction: %.1f%%\n",
            (1 - sum(fleet_detail$total_byc_mitigated) / sum(fleet_detail$total_byc_baseline)) * 100))
```


IUU calculations - test
```{r}
# Step 1: Define base (legal) fishing mortality
fm2 <- 0.5  # example observed legal fishing mortality

# Step 2: Generate proportions
non_IUU <- round(runif(1, min = 0.66, max = 0.94), 2)  # legal fishing effort
IUU <- round(runif(1, min = 0.06, max = 0.34), 2)      # illegal fishing effort

# Step 3: Calculate fishing mortality components
fm2_nonIUU <- fm2  # keep legal fishing mortality fixed
fm2_IUU <- fm2 * (IUU / non_IUU)  # scale illegal mortality relative to legal

# Step 4: Total fishing mortality = legal + illegal
fm2_total <- fm2_nonIUU + fm2_IUU

```

IUU calculations - for all demo rates
```{r}
# Example proportions (same for both fisheries, or define separately)
non_IUU <- round(runif(1, min = 0.66, max = 0.94), 2)
IUU <- round(runif(1, min = 0.06, max = 0.34), 2)

# --- DEMERSAL ---
# Observed legal mortality
dem_fm_juv_leg <- dem_fm_juv
dem_fm_imm_leg <- dem_fm_imm
dem_fm_fb_leg  <- dem_fm_fb
dem_fm_sb_leg  <- dem_fm_sb
dem_fm_nb_leg  <- dem_fm_nb

# Add illegal mortality based on ratio to legal
dem_fm_juv_total <- dem_fm_juv_leg + dem_fm_juv_leg * (IUU / non_IUU)
dem_fm_imm_total <- dem_fm_imm_leg + dem_fm_imm_leg * (IUU / non_IUU)
dem_fm_fb_total  <- dem_fm_fb_leg  + dem_fm_fb_leg  * (IUU / non_IUU)
dem_fm_sb_total  <- dem_fm_sb_leg  + dem_fm_sb_leg  * (IUU / non_IUU)
dem_fm_nb_total  <- dem_fm_nb_leg  + dem_fm_nb_leg  * (IUU / non_IUU)

# --- PELAGIC ---
pel_fm_juv_leg <- pel_fm_juv
pel_fm_imm_leg <- pel_fm_imm
pel_fm_fb_leg  <- pel_fm_fb
pel_fm_sb_leg  <- pel_fm_sb
pel_fm_nb_leg  <- pel_fm_nb

pel_fm_juv_total <- pel_fm_juv_leg + pel_fm_juv_leg * (IUU / non_IUU)
pel_fm_imm_total <- pel_fm_imm_leg + pel_fm_imm_leg * (IUU / non_IUU)
pel_fm_fb_total  <- pel_fm_fb_leg  + pel_fm_fb_leg  * (IUU / non_IUU)
pel_fm_sb_total  <- pel_fm_sb_leg  + pel_fm_sb_leg  * (IUU / non_IUU)
pel_fm_nb_total  <- pel_fm_nb_leg  + pel_fm_nb_leg  * (IUU / non_IUU)

```

NEED TO UPDATE HOW I CALCULATE NON FISHING MORTALITY. 
Assuming:

s_Juv is survival rate for juveniles

dem_fm_juv and pel_fm_juv are legal fishing mortalities

You already added illegal fishing mortality using IUU / non_IUU
```{r}
# Define proportions
non_IUU <- round(runif(1, min = 0.66, max = 0.94), 2)
IUU <- round(runif(1, min = 0.06, max = 0.34), 2)

# Legal fishing mortality (already observed)
dem_fm_juv_leg <- dem_fm_juv
pel_fm_juv_leg <- pel_fm_juv

# Add illegal mortality
dem_fm_juv_total <- dem_fm_juv_leg * (1 + IUU / non_IUU)
pel_fm_juv_total <- pel_fm_juv_leg * (1 + IUU / non_IUU)

# Total fishing mortality
fm_juv_total <- dem_fm_juv_total + pel_fm_juv_total

# Now calculate non-fishing mortality
nm_juv <- (1 - s_Juv) - fm_juv_total



# Legal fishing mortality (already observed)
dem_fm_imm_leg <- dem_fm_imm
pel_fm_imm_leg <- pel_fm_imm

# Add illegal mortality
dem_fm_imm_total <- dem_fm_imm_leg * (1 + IUU / non_IUU)
pel_fm_imm_total <- pel_fm_imm_leg * (1 + IUU / non_IUU)


# Total fishing mortality
fm_imm_total <- dem_fm_imm_total + pel_fm_imm_total

# Now calculate non-fishing mortality
nm_imm <- (1 - s_Imm) - fm_imm_total

```
This ensures that survival is consistent with the sum of all mortality sources.

If nm_juv becomes negative, that would indicate an inconsistency — i.e., fishing mortality exceeds total allowed mortality based on survival (i.e., (1 - s_Juv)), which may warrant checking.

















CODE NOT YET UPDATED BELOW _ THESE USE OLD MATRIX AND VRS 

*incorporate vital rate uncertainty*
**first, set VR uncertainty from beta dist**
```{r}
#set mean, CI for each vital rate, use these to pull VR rates within beta distribution
#s_c2


#breeding prob
b_EF	<- 0.746 #experienced failed
b_EFmean <-0.746
b_EFupper_CI <- 0.716
b_EFlower_CI <- 0.786
  
b_EFSE <- (b_EFupper_CI - b_EFlower_CI) / 3.92

b_EFvar <- b_EFSE^2

b_EFalpha = b_EFmean * ((1 - b_EFmean) / b_EFvar - 1 / b_EFmean)
b_EFbeta = (1 - b_EFmean) * ((1 -b_EFmean) /b_EFvar - 1 / (1 - b_EFmean))


b_ENB	<- 0.589 #experienced non breeding
b_ES  <- 0.016 #experienced successful
b_IF  <- 0.744 #inexperienced failed
b_Imm	<- 0.101 #immature
b_IS  <- 0.011 #inexperienced successful
b_PF	<- 0.941 #sabbatical 

#success prob
k_EF	<- 0.631 #experienced failed
k_ENB	<- 0.675 #experienced non breeding
k_ES	<- 0.500 #experienced successful
k_IF	<- 0.627 #inexperienced failed
k_Imm	<- 0.585 #immature
k_IS	<- 0.627 #inexperienced successful
k_PF	<- 0.791 #sabbatical 

#return prob
r_EF	<- 0.973 #experienced failed
r_ENB	<- 0.953 #experienced non breeding
r_ES	<- 0.292 #experienced successful
r_IF	<- 0.948 #inexperienced failed
r_Imm	<- 0.692 #immature
r_IS	<- 0.459 #inexperienced successful
r_PF	<- 0.972 #sabbatical 

#survival
s_EF	<- 0.913 #experienced failed
s_ENB	<- 0.943 #experienced non breeding
s_ES	<- 0.895 #experienced successful
s_IF	<- 0.920 #inexperienced failed
s_Imm	<- 0.921 #immature
s_IS	<- 0.892 #inexperienced successful
s_Juv	<- 0.846 #juvenile
s_PF	<- 0.935 #sabbatical     


s_c2mean <-0.64
s_c2upper_CI <- 0.65
s_c2lower_CI <- 0.63
  
s_c2SE <- (s_c2upper_CI - s_c2lower_CI) / 3.92

s_c2var <- s_c2SE^2

s_c2alpha = s_c2mean * ((1 - s_c2mean) / s_c2var - 1 / s_c2mean)
s_c2beta = (1 - s_c2mean) * ((1 -s_c2mean) /s_c2var - 1 / (1 - s_c2mean))

#s_cc2
s_cc2mean <-0.7244736
s_cc2upper_CI <- 0.73
s_cc2lower_CI <- 0.72
  
s_cc2SE <- (s_cc2upper_CI - s_cc2lower_CI) / 3.92

s_cc2var <- s_cc2SE^2

s_cc2alpha = s_cc2mean * ((1 - s_cc2mean) / s_cc2var - 1 / s_cc2mean)
s_cc2beta = (1 - s_cc2mean) * ((1 -s_cc2mean) /s_cc2var - 1 / (1 - s_cc2mean))

#s_j2
#s_j2mean <-0.825
s_j2mean <-0.85
s_j2upper_CI <- 0.85
# s_j2upper_CI <- 0.89
s_j2lower_CI <- 0.8
  
s_j2SE <- (s_j2upper_CI - s_j2lower_CI) / 3.92

s_j2var <- s_j2SE^2

s_j2alpha = s_j2mean * ((1 - s_j2mean) / s_j2var - 1 / s_j2mean)
s_j2beta = (1 - s_j2mean) * ((1 -s_j2mean) /s_j2var - 1 / (1 - s_j2mean))

# s_i2
 #s_i2mean <-0.925
 s_i2mean <-0.92
 s_i2upper_CI <- 0.94
 s_i2lower_CI <- 0.91
  
 s_i2SE <- ( s_i2upper_CI -  s_i2lower_CI) / 3.92

 s_i2var <-  s_i2SE^2

 s_i2alpha =  s_i2mean * ((1 -  s_i2mean) /  s_i2var - 1 /  s_i2mean)
 s_i2beta = (1 -  s_i2mean) * ((1 - s_i2mean) / s_i2var - 1 / (1 -  s_i2mean))
 
# s_s2
 #s_s2mean <-0.944
 s_s2mean <-0.94
 s_s2upper_CI <- 0.95
 s_s2lower_CI <- 0.94
  
 s_s2SE <- ( s_s2upper_CI -  s_s2lower_CI) / 3.92

 s_s2var <-  s_s2SE^2

 s_s2alpha =  s_s2mean * ((1 -  s_s2mean) /  s_s2var - 1 /  s_s2mean)
 s_s2beta = (1 -  s_s2mean) * ((1 - s_s2mean) / s_s2var - 1 / (1 -  s_s2mean))
 
 # s_a2
 #s_a2mean <-0.945
  s_a2mean <-0.94
 s_a2upper_CI <- 0.95
 s_a2lower_CI <- 0.94
  
 s_a2SE <- ( s_a2upper_CI -  s_a2lower_CI) / 3.92

 s_a2var <-  s_a2SE^2

 s_a2alpha =  s_a2mean * ((1 -  s_a2mean) /  s_a2var - 1 /  s_a2mean)
 s_a2beta = (1 -  s_a2mean) * ((1 - s_a2mean) / s_a2var - 1 / (1 -  s_a2mean))

 
  # bs_a2
 bs_a2mean <-0.76
 bs_a2upper_CI <- 0.8
 bs_a2lower_CI <- 0.68
  
 bs_a2SE <- ( bs_a2upper_CI -  bs_a2lower_CI) / 3.92

 bs_a2var <-  bs_a2SE^2

 bs_a2alpha =  bs_a2mean * ((1 -  bs_a2mean) /  bs_a2var - 1 /  bs_a2mean)
 bs_a2beta = (1 -  bs_a2mean) * ((1 - bs_a2mean) / bs_a2var - 1 / (1 -  bs_a2mean))
 
 
   # bp_a2
 bp_a2mean <-0.45
 bp_a2upper_CI <- 0.7
 bp_a2lower_CI <- 0.4
  
 bp_a2SE <- ( bp_a2upper_CI -  bp_a2lower_CI) / 3.92

 bp_a2var <-  bp_a2SE^2

 bp_a2alpha =  bp_a2mean * ((1 -  bp_a2mean) /  bp_a2var - 1 /  bp_a2mean)
 bp_a2beta = (1 -  bp_a2mean) * ((1 - bp_a2mean) / bp_a2var - 1 / (1 -  bp_a2mean))
 
#fm2
# BPUE_1000 <- ((0.5460*0.0108)+(0.3276*0.0066)+(0.4169*0.1111)+(0.0120*0)+(0.2690*0.044)+(0.01060*0.044))/6 
# hooks <- 6710000 #average annual number of hooks in South West Atlantic from 1999-2009(Jimenez et al 2016, table 1)
# BPUE_1 <- BPUE_1000/1000 #convert to per 1 hook rate
# bycatch_mortality <- BPUE_1*hooks #multiply by average annual hooks
# per_cap_bycatch_mortality <- bycatch_mortality/SG_pop


fm2_mean <- fm
fm2_upperCI <- (((0.4169*0.1111)/1000)*hooks)/SG_pop
fm2_lowerCI <- (((0.01060*0.044)/1000)*hooks)/SG_pop

fm2_SE <- ( fm2_upperCI -  fm2_lowerCI) / 3.92

fm2_var <-  fm2_SE^2

fm2_alpha =  fm2_mean * ((1 -  fm2_mean) /  fm2_var - 1 /  fm2_mean)
fm2_beta = (1 -  fm2_mean) * ((1 - fm2_mean) / fm2_var - 1 / (1 -  fm2_mean))

```

*constrain by biology*
*take rescaled version, add a if next statement to skip any runs where js is higher than s or a s*
*then, filter data to remove any columns where the 0 reduction scenario yields lambda >1, or where with just natural mortality and full mitigation lambda is <1*
```{r}
full_output_IUU <- vector("list", 6)
bycatch_reductions2 <- seq(0, 1, by =0.01)
mitigation_eff_range <- seq(0.5,1, by  = 0.1)
sims = 1:1000



set.seed(123)

for(k in 1:length(mitigation_eff_range)){
  mit_eff <- mitigation_eff_range[k]
  
  output2_IUU <- matrix(nrow = length(bycatch_reductions2), ncol = length(sims)) %>% as.data.frame() 
  
for(j in 1:length(sims)){
    
  set.seed(j)
  
    s_c2 <-    rbeta(n = 1, shape1 = s_c2alpha, shape2 = s_c2beta) #chick+ fledgling survival year 0-1 - 0.64 
    s_cc2 <-  rbeta(n = 1, shape1 = s_cc2alpha, shape2 = s_cc2beta) # conditional chick+ fledgling survival year 0-1 - 0.64 
    s_j2 <- rbeta(n = 1, shape1 = s_j2alpha, shape2 = s_j2beta)#juvenile survival year 1-3 -  0.8 
    s_i2 <-  rbeta(n = 1, shape1 = s_i2alpha, shape2 = s_i2beta) #immature survival year 3-7 -  0.92
    s_s2 <- rbeta(n = 1, shape1 = s_s2alpha, shape2 = s_s2beta) #subadult survival year 7-10 - 0.94
    s_a2 <-  rbeta(n = 1, shape1 = s_a2alpha, shape2 = s_a2beta) #adult survival year 10+ - 0.94
    bs_a2 <-  rbeta(n = 1, shape1 = bs_a2alpha, shape2 = bs_a2beta) #adult breeding success - 0.8 
    bp_a2 <-  rbeta(n = 1, shape1 = bp_a2alpha, shape2 = bp_a2beta)  #adult breeding probablity (biennial breeding, most breeding by age 10) - 0.45
    c2 <- 0.5# # of female chicks per year
    f_a2 <- bp_a*c2*s_cc2 #fecundity

    
      # Check the condition and skip to the next iteration if it's true
  if (s_j2 > s_s2 || s_j2 > s_a2 || s_j2 > s_i2 || s_i2 > s_s2 || s_i2 > s_a2 || s_s2 > s_a2) {
    next
  }
    
    
    #fishing mortality = per capita calculation above
   # fm2 <- fm #set bycatch mortality
    fm2 <-  rbeta(n = 1, shape1 = fm2_alpha, shape2 = fm2_beta)  #variable bycatch mortality
    
    #natural mortality
    nm_j2 <- (1-s_j2)-fm2
    nm_i2 <- (1-s_i2)-fm2
    nm_s2 <- (1-s_s2)-fm2
    nm_a2 <- (1-s_a2)-fm2
    
    #need to calculate legal fishing, illegal fishing mortality, and non fishing mortality, and only module fishing mortality
    non_IUU_count<- round(runif(1, min = 66, max = 94))
    non_IUU<- round(runif(1, min = 0.66, max = 0.94),2)
    IUU <- round(runif(1, min =0.06, max = 0.34),2)
  
    fm2_nonIUU <- fm2*non_IUU
    fm2_IUU <- fm2*IUU
    
    
    bycatch_reductions2b<- bycatch_reductions2*non_IUU
    
for(i in 1:length(bycatch_reductions2)){
 #   for(i in 1:non_IUU_count){
  
  #calculate new survival rates = 1-(bycatch mortality*(1-efficacy of intervention action * proportion of legal fishery implementing intervention actions * prop of legal fishery to total fishery))+mortality remainder)

  n_s_j2 <- 1-((fm2_nonIUU*(1-(mit_eff*bycatch_reductions2b[i])))+(nm_j2)+fm2_IUU)
  n_s_i2 <- 1-((fm2_nonIUU*(1-(mit_eff*bycatch_reductions2b[i])))+(nm_i2)+fm2_IUU)
  n_s_s2 <- 1-((fm2_nonIUU*(1-(mit_eff*bycatch_reductions2b[i])))+(nm_s2)+fm2_IUU)
  n_s_a2 <- 1-((fm2_nonIUU*(1-(mit_eff*bycatch_reductions2b[i])))+(nm_s2)+fm2_IUU)
  

   #Age classes (years)    0-1      1-2      2-3     3-4     4-5     5-6     6-7    7-8     8-9      nw,                w1,                  w2,                   w3,                   w4
  n_m2_IUU <- matrix(data = c( 0,       0,       0,      0,      0,      0,      0,      0,      0,      n_s_a2^2*f_a2,     n_s_a2^2*f_a2*w,     n_s_a2^2*f_a2*w,      n_s_a2^2*f_a2*w,      n_s_a2^2*f_a2*w4,      #0-1
                           n_s_j2,  0,       0,      0,      0,      0,      0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #1-2
                           0,       n_s_j2,  0,      0,      0,      0,      0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #2-3
                           0,       0,       n_s_j2, 0,      0,      0,      0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #3-4
                           0,       0,       0,      n_s_i2, 0,      0,      0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #4-5
                           0,       0,       0,      0,      n_s_i2, 0,      0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #5-6
                           0,       0,       0,      0,      0,      n_s_i2, 0,      0,      0,      0,                 0,                   0,                    0,                    0,                     #6-7
                           0,       0,       0,      0,      0,      0,      n_s_i2, 0,      0,      0,                 0,                   0,                    0,                    0,                     #7-8
                           0,       0,       0,      0,      0,      0,      0,      n_s_s2, 0,      0,                 0,                   0,                    0,                    0,                     #8-9
                           0,       0,       0,      0,      0,      0,      0,      0,      n_s_s2, n_s_a2^2,          n_s_a2^2*w,          n_s_a2^2*w,           n_s_a2^2*w,           n_s_a2^2*w4,           #nw
                           0,       0,       0,      0,      0,      0,      0,      0,      0,      n_s_a2*(1-n_s_a2), n_s_a2*(1-n_s_a2)*w, n_s_a2*(1-n_s_a2)*w,  n_s_a2*(1-n_s_a2)*w,  n_s_a2*(1-n_s_a2)*w4,  #w1
                           0,       0,       0,      0,      0,      0,      0,      0,      0,      0,                 n_s_a2*(1-w),        0,                    0,                    0,                     #w2
                           0,       0,       0,      0,      0,      0,      0,      0,      0,      0,                 0,                   n_s_a2*(1-w),         0,                    0,                     #w3
                           0,       0,       0,      0,      0,      0,      0,      0,      0,      0,                 0,                   0,                    n_s_a2*(1-w),         0),                    #w4
                   nrow = 14, byrow = TRUE)
n_m2_IUU
  
   
  
  #extract eigenvalues and lambda from the matrix 
  n_m2_IUU_eig2 <- eigen(n_m2_IUU)
  lambda_n2_IUU <- as.numeric(n_m2_IUU_eig2$values[1])
  output2_IUU[i,j] <- lambda_n2_IUU # this matches the ideal population growth rate in the table
   output2_IUU <- as.data.frame(output2_IUU)
   output2_IUU$mitigation_efficacy <- mit_eff
  output2_IUU$bycatch_reduction <- bycatch_reductions2
   full_output_IUU[[k]] <- output2_IUU


    }

}
}

full_output_IUU[[1]]
 sim_results_IUU<- full_output_IUU[[1]]
 sim_results_IUU$quantile5 <-  apply(sim_results_IUU[1:100], 1, quantile, (probs =c(0.05)), na.rm=TRUE)
 sim_results_IUU$quantile95 <-  apply(sim_results_IUU[1:100], 1, quantile, (probs =c(0.95)), na.rm=TRUE)
 
 
```

*format output*
```{r}
mitigation_eff_range #0.5 0.6 0.7 0.8 0.9 1.0

mit05_l_IUU <- full_output_IUU[[1]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")
mit06_l_IUU  <- full_output_IUU[[2]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")
mit07_l_IUU  <- full_output_IUU[[3]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")
mit08_l_IUU  <- full_output_IUU[[4]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")
mit09_l_IUU  <- full_output_IUU[[5]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")
mit1_l_IUU  <- full_output_IUU[[6]] %>% 
  select_if(~all(!is.na(.))) %>% 
  pivot_longer(cols = starts_with("V"), names_to = "simrun", values_to = "lambda")

fulldat_IUU  <- rbind(mit05_l_IUU,mit06_l_IUU,mit07_l_IUU,mit08_l_IUU,mit09_l_IUU,mit1_l_IUU)
fulldat_IUU$mitsim <- paste(fulldat_IUU$mitigation_efficacy, fulldat_IUU$simrun)

mit05_IUU  <- full_output_IUU[[1]] %>%  select_if(~all(!is.na(.)))
mit06_IUU  <- full_output_IUU[[2]] %>%  select_if(~all(!is.na(.)))
mit07_IUU  <- full_output_IUU[[3]] %>%  select_if(~all(!is.na(.)))
mit08_IUU  <- full_output_IUU[[4]] %>%  select_if(~all(!is.na(.)))
mit09_IUU  <- full_output_IUU[[5]] %>%  select_if(~all(!is.na(.)))
mit1_IUU  <- full_output_IUU[[6]] %>%  select_if(~all(!is.na(.)))

full_dat_w_IUU <- rbind(mit05_IUU ,mit06_IUU ,mit07_IUU ,mit08_IUU ,mit09_IUU ,mit1_IUU )
# full_dat_w_IUU$quantile5 <-  apply(full_dat_w_IUU[1:100], 1, quantile, (probs =c(0.05)))
# full_dat_w_IUU$quantile95 <-  apply(full_dat_w_IUU[1:100], 1, quantile, (probs =c(0.95)))
# full_dat_w_IUU$quantile25 <-  apply(full_dat_w_IUU[1:100], 1, quantile, (probs =c(0.25)))
# full_dat_w_IUU$quantile75 <-  apply(full_dat_w_IUU[1:100], 1, quantile, (probs =c(0.75)))
full_dat_w_IUU$mitsim <- paste(full_dat_w_IUU$mitigation_efficacy, full_dat_w_IUU$simrun)

```

*plot VR uncertainty plots*
```{r}
output_l$mitigation_efficacy <- output_l$mit_eff
fulldat_IUU <- fulldat_IUU %>% group_by(mitigation_efficacy, bycatch_reduction) %>% mutate(mean_lambda = mean(lambda)) %>% ungroup()

ggplot(fulldat_IUU)+
  geom_line(aes(x=bycatch_reduction, y=lambda, group = simrun), color = "grey", alpha = 0.1)+
 # geom_line(data = output_l, aes(x=bycatch_reductions, y=lambda))+ #"best" VR
  geom_hline(aes(yintercept = 1), color = "red", alpha =0.5)+ 
  geom_line(aes(x=bycatch_reduction, y=mean_lambda, group = simrun), color = "blue")+ #mean VR
  labs(x="% fisheries with bycatch mitigation", y="lambda")+
  facet_wrap(~mitigation_efficacy, nrow = 1)+
  themeo+
  coord_cartesian(expand=FALSE)
```


